<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DUNE-DAQ: appfwk: The DUNE DAQ Application Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DUNE-DAQ
   </div>
   <div id="projectbrief">DUNE Trigger and Data Acquisition software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">appfwk: The DUNE DAQ Application Framework</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md451"></a> </p>
<h1><a class="anchor" id="autotoc_md452"></a>
Overview</h1>
<p><b>In a single sentence:</b></p>
<p>appfwk consists of a generic DAQ application (<code>daq_application</code>) which can be configured to run different types of DAQ modules performing various DAQ-related tasks, where DAQ modules are user-developed implementations of appfwk's <code>DAQModule</code> interface class.</p>
<p><b>In a bit more detail:</b></p>
<p>appfwk provides the scaffolding on which all DUNE DAQ software processes can be developed. The running DAQ typically consists of multiple distinct processes assigned various tasks: filtering data, requesting it, saving it to storage, etc. There are many different types of process, some of which may not even have been conceived of yet, and it would be cumbersome to recompile multiple different types of process across many packages every time one wanted to change the behavior of the DAQ. To solve this problem, the approach that's been taken is to have a standard DUNE DAQ software process <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2appfwk_2docs_2Daq-Application.html">`daq_application`</a> which can be configured at runtime by Run Control in order to perform some particular function in the DAQ.</p>
<p><code>daq_application</code> is designed as a flexible container of "DAQ modules" (units of code designed to perform specific tasks) and "connections" (designed to move data between DAQ modules that can be in the same or in different DAQ applications). These specific tasks can vary widely; they include <a href="https://github.com/DUNE-DAQ/readoutmodules/blob/develop/plugins/FakeCardReader.hpp">producing fake data for testing purposes</a>, <a href="https://github.com/DUNE-DAQ/dfmodules/blob/develop/plugins/DataWriterModule.hpp">putting data into long term storage</a>, and so forth. DAQ modules will typically execute user-defined functions when receiving standard transitions from Run Control: "conf", "start", etc. appfwk provides the <code>DAQModule</code> base class which users should derive their DAQ module class from in their own packages. Read more about ActionPlans <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2appfwk_2docs_2ActionPlans.html">here</a>.</p>
<p><img src="https://github.com/DUNE-DAQ/appfwk/raw/develop/docs/Application.png" alt="daq_application" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md453"></a>
Running &lt;tt&gt;daq_application&lt;/tt&gt;</h1>
<p>In general, in a full blown DAQ system users won't be running <code>daq_application</code> from the command line. However, it can be instructive to know what options <code>daq_application</code> takes. Details can be found <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2appfwk_2docs_2Daq-Application.html">here</a>.</p>
<p><a class="anchor" id="Writing_DAQ_modules"></a> </p>
<h1><a class="anchor" id="autotoc_md454"></a>
Writing DAQ modules</h1>
<h2><a class="anchor" id="autotoc_md455"></a>
Basics of the &lt;tt&gt;DAQModule&lt;/tt&gt; interface</h2>
<p>**_Be aware that much of the boilerplate code described below can be automatically generated using the <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/daq-cmake/#the-create_dunedaq_package-script">create_dunedaq_package script</a>_**</p>
<p>When implenting a DAQ module, you'll want to <code>#include</code> the <a href="https://github.com/DUNE-DAQ/appfwk/blob/develop/include/appfwk/DAQModule.hpp"><code>DAQModule.hpp</code> header</a>, and derive your DAQ module from the <code>DAQModule</code> base class. The most important parts of <code><a class="el" href="DAQModule_8hpp.html">DAQModule.hpp</a></code> to an implementor of a DAQ module are the following:</p><ul>
<li><code>DEFINE_DUNE_DAQ_MODULE</code>: This is a macro which should be "called" at the bottom of your DAQ module's source file with an "argument" of the form <code>dunedaq::&lt;your_package_name&gt;::&lt;your DAQ module name&gt;</code>. E.g., <code><a class="el" href="DAQModule_8hpp.html#a6bec8212d0ed6f48f28d0b16851148f4" title="Declare the function that will be called by the plugin loader.">DEFINE_DUNE_DAQ_MODULE(dunedaq::dfmodules::DataWriterModule)</a></code> <a href="https://github.com/DUNE-DAQ/dfmodules/blob/develop/plugins/DataWriterModule.cpp">at the bottom of the dfmodules package's DataWriterModule module's source file</a></li>
<li><code>register_command</code>: takes as arguments the name of a command and a function which should execute when the command is received. The function is user defined, and takes an instance of <code>DAQModule::data_t</code> as argument. <code>DAQModule::data_t</code> is aliased to the <code>nlohmann::json</code> type and can thus be thought of as a blob of JSON-structured data. While in principle any arbitary name could be associated with any function of arbitrary behavior to create a command, in practice implementors of DAQ modules define commands associated with the DAQ's state machine: "_conf_", "_start_", "_stop_", "_scrap_". Not all DAQ modules necessarily need to perform an action for each of those transitions; e.g., a module may only be designed to do something during configuration, and not change as the DAQ enters the running state ("_start_") or exits it ("_stop_"). It also supports an optional third argument which lists the states that the application must be in for the command to be valid. [!!!Control People here should make comments and see if this is correct, if it's sitll the plan, etc]</li>
<li><code>init</code>: this pure virtual function's implementation is meant to create objects which are persistent for the lifetime of the DAQ module. It also has the unique role of connecting the DAQModel with its own configuration object, see later the init section for more details. It takes as an argument the type <code>std::shared_ptr&lt;ModuleConfiguration&gt;</code>. Typically, <code>init</code> will take the generic configuration object (<code>ModuleConfiguration</code>), extract the configuration object specifically defined for this <code>DAQModule</code> and will store the pointer internally to the class for later usage, when the dedicated commands comes, usually <code>conf</code>. Connection, as they are persistent objects, are commonly allocated in <code>init</code>; they'll be described in more detail later in this document.</li>
</ul>
<p>An conceptual example of what this looks like is the following simplified version of a DAQ module implementation. </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// This file would be called plugins/MyDaqModule.hpp</span></div>
<div class="line"><span class="comment">// Functions would typically be defined in plugins/MyDaqModule.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyDaqModule : <span class="keyword">public</span> dunedaq::appfwk::DAQModule {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">     MyDaqModule(<span class="keyword">const</span> std::string&amp; name) : <span class="comment">// A DAQ module instance is meant to have a unique name</span></div>
<div class="line">        <a class="code hl_namespace" href="namespacedunedaq.html">dunedaq</a>::<a class="code hl_namespace" href="namespaceappfwk.html">appfwk</a>::DAQModule(name)</div>
<div class="line">          {</div>
<div class="line">          register_command(<span class="stringliteral">&quot;conf&quot;</span>,  &amp;MyDAQModule::do_conf);</div>
<div class="line">          register_command(<span class="stringliteral">&quot;start&quot;</span>, &amp;MyDAQModule::do_start);</div>
<div class="line">          register_command(<span class="stringliteral">&quot;stop&quot;</span>,  &amp;MyDAQModule::do_stop);</div>
<div class="line">          register_command(<span class="stringliteral">&quot;scrap&quot;</span>, &amp;MyDAQModule::do_scrap);</div>
<div class="line">     }</div>
<div class="line">     </div>
<div class="line">     <span class="keywordtype">void</span> <a class="code hl_function" href="conversions-impl_8hh.html#abc17b6b13a1a08d0e3b2b90a2533f807">init</a>(std::shared_ptr&lt;ModuleConfiguration&gt;) <span class="keyword">override</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">  </div>
<div class="line">     <span class="keywordtype">void</span> do_conf(<span class="keyword">const</span> data_t&amp; conf_data);</div>
<div class="line">     <span class="keywordtype">void</span> do_start(<span class="keyword">const</span> data_t&amp; start_data);</div>
<div class="line">     <span class="keywordtype">void</span> do_stop(<span class="keyword">const</span> data_t&amp; stop_data);</div>
<div class="line">     <span class="keywordtype">void</span> do_scrap(<span class="keyword">const</span> data_t&amp; scrap_data);</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">const</span> MyDAQModuleConf * m_cfg = <span class="keyword">nullptr</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aconversions-impl_8hh_html_abc17b6b13a1a08d0e3b2b90a2533f807"><div class="ttname"><a href="conversions-impl_8hh.html#abc17b6b13a1a08d0e3b2b90a2533f807">init</a></div><div class="ttdeci">void init(unordered_map&lt; std::string, std::string &gt; params)</div><div class="ttdef"><b>Definition</b> <a href="conversions-impl_8hh_source.html#l00030">conversions-impl.hh:30</a></div></div>
<div class="ttc" id="anamespaceappfwk_html"><div class="ttname"><a href="namespaceappfwk.html">appfwk</a></div><div class="ttdef"><b>Definition</b> <a href="appfwk_2python_2appfwk_2utils_8py_source.html#l00001">utils.py:1</a></div></div>
<div class="ttc" id="anamespacedunedaq_html"><div class="ttname"><a href="namespacedunedaq.html">dunedaq</a></div><div class="ttdoc">Including Qt Headers.</div><div class="ttdef"><b>Definition</b> <a href="DataStore_8hpp_source.html#l00057">DataStore.hpp:57</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md456"></a>
Overview of additional function-by-function descriptions</h2>
<p>A set of programming idioms have been developed over the first year of DAQ module development which, while not strictly necessary for implementing DAQ modules, have proven to be quite useful. They'll be described within the context of the functions above, as well as some new functions described later. While writers of DAQ modules should follow the coding guidelines presented in the <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/styleguide/">DUNE DAQ C++ Style Guide</a>, the techniques which will be presented below concern a higher-level view of the code and unlike the guidelines are more recommendations than requirements. Of course, you can also see the techniques in action by looking at the source code of actual DAQ modules.</p>
<h2><a class="anchor" id="autotoc_md457"></a>
The DAQ module's constructor</h2>
<p>While of course all member data will be initialized here in a <em>technical</em> (as opposed to logical) sense, in general the only things about a DAQ module instance which are meaningfully defined in its constructor are:</p><ol type="1">
<li>Its command set, already discussed</li>
<li>Its unique name, via the argument to its constructor</li>
</ol>
<p>A word needs to be said about the concept of a "unique name" here. Looking in <a href="https://github.com/DUNE-DAQ/appfwk/blob/develop/include/appfwk/DAQModule.hpp"><code>DAQModule.hpp</code></a>, you'll see that the <code>DAQModule</code> base class itself inherits from an appfwk class called <a href="https://github.com/DUNE-DAQ/appfwk/blob/develop/include/appfwk/NamedObject.hpp"><code>NamedObject</code></a>. The instances of any class which inherits from <code>NamedObject</code> will require unique names; while this of course would include DAQ modules as they inherit from <code>DAQModule</code>, <a href="https://github.com/DUNE-DAQ/dfmodules/blob/a91706c214f9ae7f1cca0840af7d0381569be83f/src/dfmodules/TriggerInhibitAgent.hpp">other types of class can require unique names as well</a>.</p>
<h2><a class="anchor" id="autotoc_md458"></a>
The &lt;tt&gt;init&lt;/tt&gt; function</h2>
<p>Already touched upon above, this function takes a <code>std::shared_ptr&lt;ModuleConfiguration&gt;</code> instance to tell it what objects to make persistent over the DAQ module's lifetime. A very common example of this is the construction of the <code>iomanager</code> connections which will pipe data into and out of an instance of the DAQ module. A description of this common use case will illustrate a couple of very important aspects of DAQ module programming.</p>
<p>When a DAQ module writer wants to communicate with other DAQ modules, they use the <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/iomanager/#connectionid-connectionref"><code>iomanager</code></a>. The <code>iomanager</code> Sender and Receiver objects needed by a DAQ Module get built in the call to <code>init</code> based on the JSON configuration <code>init</code> receives . A definition of <code>init</code>, then, can look like the following: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::init(std::shared_ptr&lt;ModuleConfiguration&gt; p) {</div>
<div class="line">    m_cfg = p-&gt;module&lt;MyDAQModuleConf&gt;(get_name());</div>
<div class="line">    <span class="keywordflow">if</span> ( !m_cfg ) {</div>
<div class="line">      <span class="keywordflow">throw</span> appfwk::CommandFailed(<a class="code hl_define" href="LocalContext_8hpp.html#adea523c3dfceb9683f7acb5e719283ee">ERS_HERE</a>, <span class="stringliteral">&quot;init&quot;</span>, get_name(), <span class="stringliteral">&quot;Unable to retrieve configuration object&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> inputs = m_cfg-&gt;get_inputs();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> con : inputs) {</div>
<div class="line">      <span class="keywordflow">if</span> (con-&gt;get_data_type() == datatype_to_string &lt;MyType1&gt;()) {</div>
<div class="line">        m_type1_con = con-&gt;UID();</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (con-&gt;get_data_type() == datatype_to_string&lt;MyType2&gt;()) {</div>
<div class="line">        <span class="keyword">auto</span> iom = iomanager::IOManager::get();</div>
<div class="line">        m_type2_receiver = iom-&gt;get_receiver&lt;MyType2&gt;(con-&gt;UID());</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aLocalContext_8hpp_html_adea523c3dfceb9683f7acb5e719283ee"><div class="ttname"><a href="LocalContext_8hpp.html#adea523c3dfceb9683f7acb5e719283ee">ERS_HERE</a></div><div class="ttdeci">#define ERS_HERE</div><div class="ttdef"><b>Definition</b> <a href="LocalContext_8hpp_source.html#l00130">LocalContext.hpp:130</a></div></div>
</div><!-- fragment --><p> In the code above, the configuration object is first extracted and then queried for the possible input connections. The information on the data type transmitted in the connection is used to decide what to use it for. The input of <code>MyType1</code> is simply used to store the name of the connection for later usage, while the inptu of <code>MyType2</code> is used to directly obtain the receiver socket from the <code>IOManager</code>. Similar operations can be done on the outputs, for example see the <a href="https://github.com/DUNE-DAQ/dfmodules/blob/2e9fc856e82cf566c2d38d024960a74cee910e75/plugins/TRBModule.cpp#L110"><code>TRBModule</code></a>. Of course in this case operations can be more complicatd because modules with multiple outputs of the same type might require a bit of more logic to organise where to send data. In that case ad-hoc solutions need to be adopted based on configuration schema object that is defined.</p>
<p>This code of course raises the question: what <em>is</em> <code>MyDAQModuleConf</code>? It's a <code>class</code>, but rather than being manually written the code for it is generated by the DUNE DAQ build system itself, using a <code>oks</code> file schema as input. Initial documentation on OKS can be found <a href="https://github.com/DUNE-DAQ/dal/blob/develop/docs/README.md">here</a>. It's in the schema file that the logical contents of the struct are defined; an example of this type of file can be found <a href="https://github.com/DUNE-DAQ/listrev/blob/develop/schema/listrev/listrev.schema.xml">here</a>. This approach allows automatic compile-time checks on the variable (here <code>MyDAQModuleConf</code>) retrieved by the module, reducing the workload on the implementor of <code>do_conf</code> or other transitions. [!!! Here some expert should decide what to do with this comment. Should we keep discussing jsonnet?!?!?]Note also that in fact many functions in a DAQ module, including <code>init</code>, can use JSON as input to control their actions, not just <code>do_conf</code>. Further details on the generation of code from <code>jsonnet</code> files are beyond the scope of appfwk documentation and are instead covered in <a href="../daq-cmake/README.md#daq_cmake_schema">this section of the daq-cmake documentation</a>.</p>
<h2><a class="anchor" id="autotoc_md459"></a>
The &lt;tt&gt;do_conf&lt;/tt&gt; function</h2>
<p>As one might expect, there are many values which a DAQ module may rely on to perform its calculations when in the running state that ideally should be settable during the <code>conf</code> transition. The typical technique is to have some member data which in the DAQ module constructor intentionally gets initialized either to zero or to implausible values (e.g. <code>m_calibration_scale_factor(-1)</code>, <code>m_num_total_warnings(0)</code>) and then to set them properly during the <code>config</code> transition. You'll see in the code below that the information is extracted from the previously set pointer to our schema generated object and is used to set the member(s). </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::do_conf(<span class="keyword">const</span> data_t&amp;)</div>
<div class="line">{</div>
<div class="line">  m_calibration_scale_factor = m_cfg-&gt;get_calibration_scale_factor();</div>
<div class="line">  <span class="comment">// ...and then set the other members which take per-configuration values...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md460"></a>
The &lt;tt&gt;do_start&lt;/tt&gt; function</h2>
<p>Most DAQ modules are designed to loop over some sort of repeated action when the DAQ enters the running state, and it's in the <code>do_start</code> function that this repeated action begins. A very common technique for the <code>do_start</code> function is, "Set an atomic boolean stating that we're now in the running state, and then start one or more threads which perform actions in loops which they break out of if they see that the atomic boolean indicates we're no longer in the running state".</p>
<p>While it's of course possible to accomplish this using the existing concurrency facilities provided by the C++ Standard Library, the <code>utilities</code> package provides a class, <code>WorkerThread</code>, which makes this easier. <code>WorkerThread</code> is covered in detail <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/utilities/WorkerThread-Usage-Notes/">here</a>; when in use the <code>do_start</code> function can be as simple as follows: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::do_start(<span class="keyword">const</span> data_t&amp; <span class="comment">/*args*/</span>) {</div>
<div class="line">    m_thread.start_working_thread();  <span class="comment">// m_thread is an `utilities::WorkerThread` member of MyDaqModule</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that <code>start_working_thread</code> takes an optional argument which gives the <code>WorkerThread</code> instance a name, potentially allowing shifters to keep track of various threads for debugging purposes.</p>
<h2><a class="anchor" id="autotoc_md461"></a>
The &lt;tt&gt;do_stop&lt;/tt&gt; function</h2>
<p>Quite simple, basically the reverse of <code>do_start</code>: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::do_stop(<span class="keyword">const</span> data_t&amp; <span class="comment">/*args*/</span>) {</div>
<div class="line">    m_thread.stop_working_thread();  <span class="comment">// m_thread is an `utilities::WorkerThread` member of MyDaqModule</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that if your <code>do_start</code> function also allocates any resources (hardware, memory, etc.) it should be deallocated here. Also, the input connections to your DAQ module should be drained. The idea is that you want your DAQ module to be able to accept a "start" transition after receiving a "stop" transition without anything from the previous run interfering. <br  />
</p>
<h2><a class="anchor" id="autotoc_md462"></a>
The &lt;tt&gt;do_scrap&lt;/tt&gt; function</h2>
<p>This is the reverse of <code>do_config</code>. Often this function isn't even needed since the values which get set in <code>do_conf</code> are completely overwritten on subsequent calls to <code>do_conf</code>. However, as the point of this function is to bring the DAQ module back to a state where it can be configured again, it's important that any hardware or memory resources which were acquired in <code>do_conf</code> are released here in <code>do_scrap</code>. <br  />
</p>
<h2><a class="anchor" id="autotoc_md463"></a>
The &lt;tt&gt;get_info&lt;/tt&gt; function</h2>
<p>Not yet mentioned, you can see in <a href="https://github.com/DUNE-DAQ/appfwk/blob/develop/include/appfwk/DAQModule.hpp"><code>DAQModule.hpp</code></a> that there's a virtual function called <code>get_info</code> which defaults to a no-op: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> get_info(opmonlib::InfoCollector&amp; <span class="comment">/*ci*/</span>, <span class="keywordtype">int</span> <span class="comment">/*level*/</span>) { <span class="keywordflow">return</span>; };</div>
</div><!-- fragment --><p> It's meant to be implemented by DAQ module writers to supply metrics about the DAQ module; an example of this can be found <a href="https://github.com/DUNE-DAQ/dfmodules/blob/develop/plugins/DataWriterModule.cpp">here</a>.</p>
<h2><a class="anchor" id="autotoc_md464"></a>
The full code</h2>
<p>Given the code features described above, <code>MyDaqModule</code> would look something like the following, ignoring things irrelevant to the pedagogy presented here, like proper error handling, log statements, <code>#include</code>s, etc. Pretend the name of the package <code>MyDaqModule</code> in is "mypackage":</p>
<ul>
<li><code>MyDaqModule.hpp</code>: <div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>MyDaqModule : <span class="keyword">public</span> dunedaq::appfwk::DAQModule {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">     </div>
<div class="line">     <span class="keyword">using </span>MyType1 = double; <span class="comment">// Pretend this module processes an incoming stream of doubles </span></div>
<div class="line">     <span class="keyword">using </span>MyType2 = int;    <span class="comment">// Pretend this module processes an incoming stream of int</span></div>
<div class="line">    </div>
<div class="line">     MyDaqModule(<span class="keyword">const</span> std::string&amp; name) : <span class="comment">// A DAQ module instance is meant to have a unique name</span></div>
<div class="line">        <a class="code hl_namespace" href="namespacedunedaq.html">dunedaq</a>::<a class="code hl_namespace" href="namespaceappfwk.html">appfwk</a>::DAQModule(name),</div>
<div class="line">        m_thread(<a class="code hl_namespace" href="namespacestd.html">std</a>::bind(&amp;MyDaqModule::do_work, this, <a class="code hl_namespace" href="namespacestd.html">std</a>::placeholders::_1)),</div>
<div class="line">        m_calibration_scale_factor(-1)</div>
<div class="line">        {</div>
<div class="line">          register_command(<span class="stringliteral">&quot;conf&quot;</span>,  &amp;MyDAQModule::do_conf);</div>
<div class="line">          register_command(<span class="stringliteral">&quot;start&quot;</span>, &amp;MyDAQModule::do_start);</div>
<div class="line">          register_command(<span class="stringliteral">&quot;stop&quot;</span>,  &amp;MyDAQModule::do_stop);</div>
<div class="line">          register_command(<span class="stringliteral">&quot;scrap&quot;</span>, &amp;MyDAQModule::do_scrap);</div>
<div class="line">        }</div>
<div class="line">     </div>
<div class="line">        <span class="keywordtype">void</span> <a class="code hl_function" href="conversions-impl_8hh.html#abc17b6b13a1a08d0e3b2b90a2533f807">init</a>(std::shared_ptr&lt;ModuleConfiguration&gt;) <span class="keyword">override</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">  </div>
<div class="line">     <span class="keywordtype">void</span> do_conf(<span class="keyword">const</span> data_t&amp; conf_data);</div>
<div class="line">     <span class="keywordtype">void</span> do_start(<span class="keyword">const</span> data_t&amp; start_data);</div>
<div class="line">     <span class="keywordtype">void</span> do_stop(<span class="keyword">const</span> data_t&amp; stop_data);</div>
<div class="line">     <span class="keywordtype">void</span> do_scrap(<span class="keyword">const</span> data_t&amp; scrap_data);</div>
<div class="line">     </div>
<div class="line">     <span class="keywordtype">void</span> do_work(std::atomic&lt;bool&gt;&amp;);</div>
<div class="line">     dunedaq::utilities::WorkerThread m_thread; </div>
<div class="line">     <span class="keywordtype">double</span> m_calibration_scale_factor;</div>
<div class="line">     <span class="keyword">const</span> MyDAQModuleConf * m_cfg = <span class="keyword">nullptr</span>;</div>
<div class="line">     std::string m_type1_con;</div>
<div class="line">     std::shared_ptr&lt;dunedaq::iomanager::ReceiverConcept&lt;MyType2&gt;&gt; m_type2_receiver;</div>
<div class="line">};</div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition</b> <a href="SchemaUtils_8hpp_source.html#l00140">SchemaUtils.hpp:140</a></div></div>
</div><!-- fragment --></li>
<li><code>MyDaqModule.cpp</code>: <div class="fragment"><div class="line"> ++</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::init(std::shared_ptr&lt;ModuleConfiguration&gt;) {</div>
<div class="line"> </div>
<div class="line">    m_cfg = p-&gt;module&lt;MyDAQModuleConf&gt;(get_name());</div>
<div class="line">    <span class="keywordflow">if</span> ( !m_cfg ) {</div>
<div class="line">      <span class="keywordflow">throw</span> appfwk::CommandFailed(<a class="code hl_define" href="LocalContext_8hpp.html#adea523c3dfceb9683f7acb5e719283ee">ERS_HERE</a>, <span class="stringliteral">&quot;init&quot;</span>, get_name(), <span class="stringliteral">&quot;Unable to retrieve configuration object&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> inputs = m_cfg-&gt;get_inputs();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> con : inputs) {</div>
<div class="line">      <span class="keywordflow">if</span> (con-&gt;get_data_type() == datatype_to_string &lt;MyType1&gt;()) {</div>
<div class="line">        m_type1_con = con-&gt;UID();</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (con-&gt;get_data_type() == datatype_to_string&lt;MyType2&gt;()) {</div>
<div class="line">        <span class="keyword">auto</span> iom = iomanager::IOManager::get();</div>
<div class="line">        m_type2_receiver = iom-&gt;get_receiver&lt;MyType2&gt;(con-&gt;UID());</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::do_conf(<span class="keyword">const</span> data_t&amp; conf_data)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_variable" href="namespaceplot__trigprim__output__data.html#a36ddbfa7e38ab6d7667b717c8e86e669">data</a> = conf_data.get&lt;mydaqmodule::Conf&gt;();</div>
<div class="line"> </div>
<div class="line">  m_calibration_scale_factor = <a class="code hl_variable" href="namespaceplot__trigprim__output__data.html#a36ddbfa7e38ab6d7667b717c8e86e669">data</a>.calibration_scale_factor;</div>
<div class="line">  <span class="comment">// ...and then set the other members which take per-configuration values...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::do_start(<span class="keyword">const</span> data_t&amp; <span class="comment">/*args*/</span>) {</div>
<div class="line">    m_thread.start_working_thread();  <span class="comment">// m_thread is an `utilities::WorkerThread` member of MyDaqModule</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::do_stop(<span class="keyword">const</span> data_t&amp; <span class="comment">/*args*/</span>) {</div>
<div class="line">    m_thread.stop_working_thread();  </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::do_scrap(<span class="keyword">const</span> data_t&amp; <span class="comment">/*args*/</span>) {</div>
<div class="line">    m_calibration_scale_factor = -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDaqModule::do_work(std::atomic&lt;bool&gt;&amp; running_flag)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">while</span> (running_flag.load()) {</div>
<div class="line">      <span class="comment">// Here we&#39;d receive data from m_required_input_ptr and presumably use m_calibration_scale_factor when processing the data</span></div>
<div class="line">   }</div>
<div class="line">}   </div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="DAQModule_8hpp.html#a6bec8212d0ed6f48f28d0b16851148f4">DEFINE_DUNE_DAQ_MODULE</a>(dunedaq::mypackage::MyDaqModule)</div>
<div class="ttc" id="aDAQModule_8hpp_html_a6bec8212d0ed6f48f28d0b16851148f4"><div class="ttname"><a href="DAQModule_8hpp.html#a6bec8212d0ed6f48f28d0b16851148f4">DEFINE_DUNE_DAQ_MODULE</a></div><div class="ttdeci">#define DEFINE_DUNE_DAQ_MODULE(klass)</div><div class="ttdoc">Declare the function that will be called by the plugin loader.</div><div class="ttdef"><b>Definition</b> <a href="DAQModule_8hpp_source.html#l00052">DAQModule.hpp:52</a></div></div>
<div class="ttc" id="anamespaceplot__trigprim__output__data_html_a36ddbfa7e38ab6d7667b717c8e86e669"><div class="ttname"><a href="namespaceplot__trigprim__output__data.html#a36ddbfa7e38ab6d7667b717c8e86e669">plot_trigprim_output_data.data</a></div><div class="ttdeci">data</div><div class="ttdef"><b>Definition</b> <a href="plot__trigprim__output__data_8py_source.html#l00010">plot_trigprim_output_data.py:10</a></div></div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md465"></a>
Final thoughts on writing DAQ modules</h2>
<p>Now that you've been given an overview of appfwk and how to write DAQ modules, you're encouraged to look at the various repos to see how other DUNE DAQ developers have written DAQ modules. The <a href="https://github.com/DUNE-DAQ/listrev">listrev</a> package is maintained as an example of simple DAQ modules, and another package with plenty of real DAQ modules to study is <a href="https://github.com/DUNE-DAQ/dfmodules/tree/develop/plugins">dfmodules</a>, modules used for dataflow purposes. Keep in mind that not all DAQ modules will adhere to the model described above, and you can judge for yourself what techniques you feel will make it easiest to write and maintain a DAQ module.</p>
<h2><a class="anchor" id="autotoc_md466"></a>
API Diagram</h2>
<p>[!!! Here we need to remake this diagram]<img src="https://github.com/DUNE-DAQ/appfwk/raw/develop/docs/appfwk.png" alt="Class Diagrams" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 24 2024 for DUNE-DAQ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
