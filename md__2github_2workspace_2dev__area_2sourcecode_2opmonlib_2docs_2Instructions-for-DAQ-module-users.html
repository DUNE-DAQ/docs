<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DUNE-DAQ: Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DUNE-DAQ
   </div>
   <div id="projectbrief">DUNE Trigger and Data Acquisition software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Getting Started</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md411"></a> </p>
<h1><a class="anchor" id="autotoc_md412"></a>
Define information structure to be monitored</h1>
<p>Before using opmonlib it is important to understand and define what needs to be monitored.</p>
<p>Monitorable objects can then be captured in a <code>schema</code> file to create C++ structs using <code>ProtoBuf</code>. Documentation and instructions on generating schema data structures and using ProtoBuf can be found in the <a href="https://protobuf.dev/programming-guides/proto3/">ProtoBuf website</a>. Relevant pages also include the description of the C++ API.</p>
<p>In general each <code>.protobuf</code> file contains definitions of blocks that are published as single units. Each <code>schema</code> file will generate a C++ header file containing the structures which hold the monitoring data, as defined in the <code>.proto</code> file. Typically each module may only need one struct to hold its monitoring information; however it is possible to create multiple nested structs within a schema, which are filled by the same module.</p>
<p>It is preferred to organise the protobuf schemas in the following way:</p>
<ul>
<li>put the opmon related schemas in <code>schema/opmon</code> inside your repository</li>
<li>try to group the schemas so that the schema used by the same modules are in the same file; the name of the file should match the name of the module</li>
<li>as protobuf generates a lot of code, there might be conflicts with our code - protect the generated code with an additional <code>opmon</code> namespace</li>
</ul>
<p>Here is an example, taken from the <code>DFOModule.proto</code>, which contains the schemas used by DFOModule plugin in dfmodules. </p><div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package dunedaq.dfmodules.opmon;</div>
<div class="line"> </div>
<div class="line">// regular metric published byt the DFO</div>
<div class="line">message DFOInfo {</div>
<div class="line">  // counters </div>
<div class="line">  uint64 tokens_received = 1;</div>
<div class="line">  uint64 decisions_received = 2;</div>
<div class="line">  uint64 decisions_sent = 3;</div>
<div class="line"> </div>
<div class="line">  // time management of the decision thread</div>
<div class="line">  uint64 waiting_for_decision = 10 ; // Time spent waiting on Trigger Decisions, in microseconds</div>
<div class="line">  uint64 deciding_destination = 11 ; // Time spent making a decision on the receving DF app, in microseconds</div>
<div class="line">  uint64 forwarding_decision = 12  ; // Time spent sending the Trigger Decision to TRBs, in microseconds</div>
<div class="line"> </div>
<div class="line">  // time management of the token thread</div>
<div class="line">  uint64 waiting_for_token = 15 ; // Time spent waiting in token thread for tokens, in microseconds</div>
<div class="line">  uint64 processing_token = 16 ; // Time spent in token thread updating data structure, in microseconds</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// these counters are published separately for each trigger type</div>
<div class="line">message TriggerInfo {</div>
<div class="line">  uint64 received = 1;</div>
<div class="line">  uint64 completed = 2;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md413"></a>
Valid types</h2>
<p>As a generic schema language, <code>ProtoBuf</code> allows you to use simple types, but also lists, maps, etc. Be aware that apart from basic types and nested messages, other quantities are ignored by the monitoring system. An <code>OpMonEntry</code> message is generated whenever a structure with at least one publishable field is passed to the <code>publish</code> method, see next section.</p>
<h1><a class="anchor" id="autotoc_md414"></a>
Filling and collecting structures</h1>
<p>The <code>ProtoBuf</code> C++ API guide describes how to fill the structures you created. In order to publish the metric, the object has to be created from within a <code>MonitorableObject</code>, see <a href="https://github.com/DUNE-DAQ/opmonlib/blob/mroda/protobuf/include/opmonlib/MonitorableObject.hpp">the header file</a>. In particular, a <code>DAQModule</code> <em>is</em> a <code>MonitorableObject</code>. Two main functions are relevant for publishing: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> publish( google::protobuf::Message &amp;&amp;,</div>
<div class="line">                CustomOrigin &amp;&amp; co = {},</div>
<div class="line">              OpMonLevel l = to_level(EntryOpMonLevel::kDefault) ) <span class="keyword">const</span> <span class="keyword">noexcept</span> ;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> generate_opmon_data(opmon_level) {<span class="keywordflow">return</span>;}</div>
</div><!-- fragment --><ul>
<li><code>publish</code> takes a ProtoBuf schema object, it timestamps it with the time of the function call, it serializes it (synchronously) and publishes it (asynchronously) via one of the configured OpMonFacilities. This function can be called at anytime.</li>
<li><code>generate_opmon_data</code> is a function which the monitoring system calls regularly (order of seconds). Its default behaviour is 'null'. Every developer can freely implement this in their MonitorableObject in order to avoid setting up a thread to generate information regularly. Specific implementations are expected to call the <code>publish</code> function to actually publish the metric.</li>
</ul>
<h2><a class="anchor" id="autotoc_md415"></a>
Example</h2>
<p>An example of metric publication is </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> DFOModule::generate_opmon_data()  {</div>
<div class="line"> </div>
<div class="line">  opmon::DFOInfo info;</div>
<div class="line">  info.set_tokens_received( m_received_tokens.exchange(0) );</div>
<div class="line">  info.set_decisions_sent(m_sent_decisions.exchange(0));</div>
<div class="line">  info.set_decisions_received(m_received_decisions.exchange(0));</div>
<div class="line">  info.set_waiting_for_decision(m_waiting_for_decision.exchange(0));</div>
<div class="line">  info.set_deciding_destination(m_deciding_destination.exchange(0));</div>
<div class="line">  info.set_forwarding_decision(m_forwarding_decision.exchange(0));</div>
<div class="line">  info.set_waiting_for_token(m_waiting_for_token.exchange(0));</div>
<div class="line">  info.set_processing_token(m_processing_token.exchange(0));</div>
<div class="line">  publish( std::move(info) );</div>
<div class="line"> </div>
<div class="line">  std::lock_guard&lt;std::mutex&gt;   guard(m_trigger_mutex);</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> &amp; [<a class="code hl_variable" href="TriggerActivity__serialization_8hpp.html#a7aead736a07eaf25623ad7bfa1f0ee2d">type</a>, counts] : m_trigger_counters ) {</div>
<div class="line">    opmon::TriggerInfo ti;</div>
<div class="line">    ti.set_received(counts.received.exchange(0));</div>
<div class="line">    ti.set_completed(counts.completed.exchange(0));</div>
<div class="line">    <span class="keyword">auto</span> name = <a class="code hl_function" href="namespacedunedaq_1_1trgdataformats.html#a16fa86c1d7c4942f9f225371ee2291d1">dunedaq::trgdataformats::get_trigger_candidate_type_names</a>()[<a class="code hl_variable" href="TriggerActivity__serialization_8hpp.html#a7aead736a07eaf25623ad7bfa1f0ee2d">type</a>];</div>
<div class="line">    publish( std::move(ti), {{<span class="stringliteral">&quot;type&quot;</span>, name}} );</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="aTriggerActivity__serialization_8hpp_html_a7aead736a07eaf25623ad7bfa1f0ee2d"><div class="ttname"><a href="TriggerActivity__serialization_8hpp.html#a7aead736a07eaf25623ad7bfa1f0ee2d">type</a></div><div class="ttdeci">type</div><div class="ttdef"><b>Definition</b> <a href="TriggerActivity__serialization_8hpp_source.html#l00048">TriggerActivity_serialization.hpp:48</a></div></div>
<div class="ttc" id="anamespacedunedaq_1_1trgdataformats_html_a16fa86c1d7c4942f9f225371ee2291d1"><div class="ttname"><a href="namespacedunedaq_1_1trgdataformats.html#a16fa86c1d7c4942f9f225371ee2291d1">dunedaq::trgdataformats::get_trigger_candidate_type_names</a></div><div class="ttdeci">std::map&lt; TriggerCandidateData::Type, std::string &gt; get_trigger_candidate_type_names()</div><div class="ttdef"><b>Definition</b> <a href="TriggerCandidateData_8hpp_source.html#l00101">TriggerCandidateData.hpp:101</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md416"></a>
Details and good practices about the optional arguments</h2>
<p>Optional arguments of the <code>publish</code> function, allow you to:</p>
<ul>
<li>specify a level of priority associated to the metric</li>
<li>add additional custom information on the source of the metric, in the form of a <code>map&lt;string, string&gt;</code>, where the key is the type of the source, e.g. channel, and the second is the value, e.g. 4345</li>
<li>extend the <code>opmon_id</code> of the caller <code>MonitorableObject</code> for the specific metric with more detailed information on the source of this metric</li>
</ul>
<p>The <code>OpMonLevel</code> is a priority level designed to control the quantity of metrics generated by a tree. As a default, all messages are published. The lower the level, the higher the priority. They system can decide to entirely disable the metric publication regardless of the OpMonLevel. The system already provides some values to specify the <code>OpMonLevel</code> via an enum: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">enum class</span> EntryOpMonLevel : OpMonLevel {</div>
<div class="line">    kTopPriority     = std::numeric_limits&lt;OpMonLevel&gt;::min(),</div>
<div class="line">    kEventDriven     = std::numeric_limits&lt;OpMonLevel&gt;::max()/4,</div>
<div class="line">    kDefault         = std::numeric_limits&lt;OpMonLevel&gt;::max()/2,</div>
<div class="line">    kLowestPrioriry  = std::numeric_limits&lt;OpMonLevel&gt;::max()-1</div>
<div class="line">  };</div>
</div><!-- fragment --><p> but users are welcome to fill the gaps with whatever number they are happy to associate with their metric.</p>
<p>The usage of a custom origin is designed to provide information that is unrelated to software stack. While the software stack might change (e.g, the name of an application or of a module can change because of configuration), some information like a crate number or a channel are hardware related and they are independent of the software stack that provides this information. Examples of valid tags to be used in the custom origins are: server name, channel, links, etc. The value of a tag should not grow indefinitely for retrival efficiency in the database. So, things like run number should not become a custom origin. Adding information like application name or session in the custom origin is discouraged because it would be redundant. In the example above, you see an usage example where <code>TriggerInfo</code> contains counters grouped by trigger type.</p>
<h1><a class="anchor" id="autotoc_md417"></a>
Registering sub components for your DAQModule</h1>
<p>In order to work correctly, each <code>MonitorableObject</code> has to be part of a monitoring tree, i.e. every <code>MonitorablreObject</code> has to be registered to the chain. This is done via the method </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> register_node( std::string name, new_node_ptr ) ;</div>
</div><!-- fragment --><p> If not registered, the metric is not completely lost, an ERS error will be generated reporting the usage of an unconfigured reporting system.</p>
<p>The metrics generated by the child will have an <code>opmon_id</code> in the form <code>parent_opmon_id.child_name</code>. The registration does not imply ownership of the child by the parent, as internally only weak pointers are utilised. If the child is destroyed, its pointer will eventually be removed from the chain.</p>
<p><code>DAQModule</code>s will be automatically registered by the application framework and developers have to write their code assuming that the module is registered in the monitoring tree from the moment of its creation. On the other hand, developers have to take care of the registration of subcomonents living inside their modules.</p>
<p>An example of registration is: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> DFOModule::receive_trigger_complete_token(<span class="keyword">const</span> dfmessages::TriggerDecisionToken&amp; token) {</div>
<div class="line">  <span class="keywordflow">if</span> (m_dataflow_availability.count(token.decision_destination) == 0) {</div>
<div class="line">    <a class="code hl_define" href="logging_2include_2logging_2Logging_8hpp.html#a8c6732348bcdf3758aac3d18eb3995b9">TLOG_DEBUG</a>(TLVL_CONFIG) &lt;&lt; <span class="stringliteral">&quot;Creating dataflow availability struct for uid &quot;</span> &lt;&lt; token.decision_destination;</div>
<div class="line">    <span class="keyword">auto</span> entry = m_dataflow_availability[token.decision_destination] =</div>
<div class="line">      std::make_shared&lt;TriggerRecordBuilderData&gt;(token.decision_destination, m_busy_threshold, m_free_threshold);</div>
<div class="line">    register_node(token.decision_destination, entry);</div>
<div class="line">  } </div>
<div class="line">}</div>
<div class="ttc" id="alogging_2include_2logging_2Logging_8hpp_html_a8c6732348bcdf3758aac3d18eb3995b9"><div class="ttname"><a href="logging_2include_2logging_2Logging_8hpp.html#a8c6732348bcdf3758aac3d18eb3995b9">TLOG_DEBUG</a></div><div class="ttdeci">#define TLOG_DEBUG(lvl,...)</div><div class="ttdef"><b>Definition</b> <a href="logging_2include_2logging_2Logging_8hpp_source.html#l00112">Logging.hpp:112</a></div></div>
</div><!-- fragment --><p> Notice that here the registraion is event driven: something triggers the creation of an object and it's possible to register the object at anytime. Of course a more static approach is possible too.</p>
<p>The registration does not imply ownership, so in order to unregister an object you just need to delete the shared pointer.</p>
<h1><a class="anchor" id="autotoc_md418"></a>
Testing</h1>
<p>The configuration of <code>opmonlib</code> is currently managed through the environment variables: <code>DUNEDAQ_OPMON_INTERVAL</code> and <code>DUNEDAQ_OPMON_LEVEL</code>. These can be seen further in <code>Application.cpp</code>: </p><div class="fragment"><div class="line">setenv(&quot;DUNEDAQ_OPMON_INTERVAL&quot;,    &quot;10&quot;,0);</div>
<div class="line">setenv(&quot;DUNEDAQ_OPMON_LEVEL&quot;,  &quot;1&quot;,0);</div>
</div><!-- fragment --><p> here, <code>DUNEDAQ_OPMON_INTERVAL</code> sets the interval in seconds between each instance of calling <code>generate_opmon_data</code> (currently defaulting to 10 seconds), and <code>DUNEDAQ_OPMON_LEVEL</code> allows the user to define the level for <code>generatre_opmon_data</code> (currently set to 1). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 24 2024 for DUNE-DAQ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
