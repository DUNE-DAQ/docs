<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DUNE-DAQ: iomanager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DUNE-DAQ
   </div>
   <div id="projectbrief">DUNE Trigger and Data Acquisition software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">iomanager</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md185"></a> A simplified API for passing messages between DAQModules</p>
<h1><a class="anchor" id="autotoc_md186"></a>
API Description</h1>
<h2><a class="anchor" id="autotoc_md187"></a>
IOManager</h2>
<ul>
<li>Main point-of-contact for Unified API</li>
<li>Methods to retrieve <code>Sender</code>/<code>Receiver</code> instances using <code>ConnectionRef</code>s or <code>uid</code> (defined below)</li>
<li>Configures <code>Queue</code>s and <code>NetworkManager</code> automatically in <code>configure</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md188"></a>
Using IOManager from DAQModule code</h2>
<ul>
<li><code><a class="el" href="namespacedunedaq.html#a54bd8d8b2b732dd5d00cbf3cc27260b2">dunedaq::get_iomanager()</a></code> will return a pointer to the IOManager singleton</li>
<li><code>IOManager::get_sender&lt;DataType&gt;(std::string uid)</code> and <code>IOManager::get_receiver&lt;DataType&gt;(std::string uid)</code> should be used to get Sender and Receiver objects connected to the appropriate connections. Note that <code>ConnectionId</code> objects are not required, as they will be constructed from the provided DataType and uid arguments.</li>
<li>Subscribers interested in multiple connections for a single DataType should use a Regular Expression to match the desired connections; this can be anywhere from a full wildcard (<code>".*"</code>) to a specific connection UID, depending on the desired scope of the subscription. Topics are now automatically assigned by IOManager as the string representation of DataType.</li>
<li>The <code>topic</code> argument has been removed from <code>SenderConcept&lt;T&gt;::send</code></li>
<li><code>appfwk</code> will give DAQModules a list of <code>appfwk::app::ConnectionReference</code> objects, which associate a "name" to connection UIDs. Methods in <code>DAQModuleHelper.hpp</code> take DAQModule configuration objects and extract specific UIDs for given names. <div class="fragment"><div class="line">++</div>
<div class="line"> <span class="keyword">auto</span> mandatory_connections =</div>
<div class="line">   appfwk::connection_index(init_data, { <span class="stringliteral">&quot;token_connection&quot;</span>, <span class="stringliteral">&quot;td_connection&quot;</span>, <span class="stringliteral">&quot;busy_connection&quot;</span> });</div>
<div class="line"> </div>
<div class="line"> m_token_connection = mandatory_connections[<span class="stringliteral">&quot;token_connection&quot;</span>];</div>
<div class="line"> m_td_connection = mandatory_connections[<span class="stringliteral">&quot;td_connection&quot;</span>];</div>
<div class="line"> <span class="keyword">auto</span> busy_connection = mandatory_connections[<span class="stringliteral">&quot;busy_connection&quot;</span>];</div>
<div class="line"> </div>
<div class="line"> m_busy_sender = iom-&gt;get_sender&lt;dfmessages::TriggerInhibit&gt;(busy_connection);</div>
</div><!-- fragment --></li>
<li>Upon agreement from both endpoints, a connection can use a generated UID string (e.g. from SourceID::to_string()).</li>
</ul>
<h2><a class="anchor" id="autotoc_md189"></a>
Other Notes for Framework Developers</h2>
<ul>
<li>The <code>serialization</code> library provides a new macro <code><a class="el" href="Serialization_8hpp.html#a9bbc4e814fffc0543d7d59d464815ea0">DUNE_DAQ_TYPESTRING(Type, string)</a></code> which is included in the standard <code>DUNE_DAQ_SERIALIZABLE</code> and <code>DUNE_DAQ_SERIALIZE_NON_INTRUSIVE</code> macros (called from the <code>dunedaq</code> namespace only). These macros define the function <code>datatype_to_string&lt;T&gt;</code> which is used by IOManager to translate a datatype to the appropriate string. This template function <b>must</b> be visible in every compilation unit sending or receiving a given type!<ul>
<li>If it is not available, an error message will be produced at runtime that IOManager was unable to find connection "uid" of type Unknown</li>
</ul>
</li>
<li>In <code>daqconf</code>, all connections and queues <b>must</b> have a declared data type that matches a call to <code>DUNE_DAQ_TYPESTRING</code>. <code>add_endpoint</code> and <code>connect_modules</code> have changed their API to accomodate this.</li>
</ul>
<h2><a class="anchor" id="autotoc_md190"></a>
ConnectionId, Connection, &amp; Queue</h2>
<ul>
<li><code>ConnectionId</code> uniquely identifies a network connection or queue<ul>
<li><code>uid</code>: String identifier for connection</li>
<li><code>data_type</code>: String representation of data type</li>
</ul>
</li>
<li><code>Connection</code> defines a network connection, with required initialization<ul>
<li><code>id</code>: <code>ConnectionId</code></li>
<li><code>connection_type</code>: Describes what kind of connection (kSendReceive, kPubSub)</li>
<li><code>uri</code>: Field is used by lower-level code to configure the connection<ul>
<li>Standard ZMQ URI should be used, e.g. <code>tcp://localhost:1234</code> (name translation is provided by IPM)</li>
</ul>
</li>
</ul>
</li>
<li><code>QueueConfig</code> represents an app-internal queue<ul>
<li><code>id</code>: <code>ConectionId</code></li>
<li><code>queue_type</code>: Type of the queue implementation (e.g. kStdDeQueue, kFollySPSCQueue, kFollyMPMCQueue)</li>
<li><code>capacity</code>: Capacity of the queue</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md191"></a>
Receiver</h2>
<ul>
<li><code>Receiver</code> is base type without template (for use in <code>IOManager::m_receiver</code>s)</li>
<li><code>ReceiverConcept</code> introduces template and serves as class given by <code>IOManager::get_receiver</code></li>
<li><code>QueueReceiverModel</code> and <code>NetworkReceiverModel</code> implement receives and callback loop for queues and network<ul>
<li><code>NetworkReceiverModel::read_network</code> determines if type is serializable using template metaprogramming</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md192"></a>
Sender</h2>
<ul>
<li>Similar design as for <code>Receiver</code>s</li>
<li><code>QueueSenderModel</code> and <code>NetworkSenderModel</code> implement sends for queues and network</li>
<li><code>NetworkReceiverModel::write_network</code> determines if type is serializable using template metaprogramming</li>
</ul>
<h2><a class="anchor" id="autotoc_md193"></a>
API Diagram</h2>
<p><img src="https://github.com/DUNE-DAQ/iomanager/raw/develop/docs/iomanager-common.png" alt="Class Diagrams" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md194"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md195"></a>
Send</h2>
<div class="fragment"><div class="line"><span class="comment">// Int sender</span></div>
<div class="line">std::string uid = <span class="stringliteral">&quot;bar&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> msg = 5;</div>
<div class="line">std::chrono::milliseconds timeout(100);</div>
<div class="line"><span class="keyword">auto</span> isender = IOManager::get()-&gt;get_sender&lt;<span class="keywordtype">int</span>&gt;(uid);</div>
<div class="line">isender-&gt;send(msg, timeout);</div>
<div class="line">isender-&gt;send(msg, timeout);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// One line send</span></div>
<div class="line">IOManager::get()-&gt;get_sender&lt;<span class="keywordtype">int</span>&gt;(uid)-&gt;send(msg, timeout);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send when timeouts may occur</span></div>
<div class="line"><span class="keywordtype">bool</span> sent = isender-&gt;try_send(msg, timeout);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md196"></a>
Receive (direct)</h2>
<div class="fragment"><div class="line"><span class="comment">// String receiver</span></div>
<div class="line">  std::string uid = <span class="stringliteral">&quot;bar&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> receiver = IOManager::get()-&gt;get_receiver&lt;std::string&gt;(uid);</div>
<div class="line">  std::string got;</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    got = receiver-&gt;receive(timeout);</div>
<div class="line">  } <span class="keywordflow">catch</span> (dunedaq::appfwk::QueueTimeoutExpired&amp;) {</div>
<div class="line">    <span class="comment">// Deal with exception</span></div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Alternate API for when timeouts may be allowed</span></div>
<div class="line">  std::optional&lt;std::string&gt; <a class="code hl_variable" href="namespacecheckLinks.html#a54e97434ff6ffa7352831fbf2a93c0c3">ret</a> = receiver-&gt;try_receive(timeout);</div>
<div class="line">  <span class="keywordflow">if</span>(ret) <a class="code hl_define" href="logging_2include_2logging_2internal_2macro_8hpp.html#a69dcfba03c6d43734c25d912a4f2288c">TLOG</a>() &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt; *<a class="code hl_variable" href="namespacecheckLinks.html#a54e97434ff6ffa7352831fbf2a93c0c3">ret</a>;</div>
<div class="ttc" id="alogging_2include_2logging_2internal_2macro_8hpp_html_a69dcfba03c6d43734c25d912a4f2288c"><div class="ttname"><a href="logging_2include_2logging_2internal_2macro_8hpp.html#a69dcfba03c6d43734c25d912a4f2288c">TLOG</a></div><div class="ttdeci">#define TLOG(...)</div><div class="ttdef"><b>Definition</b> <a href="logging_2include_2logging_2internal_2macro_8hpp_source.html#l00022">macro.hpp:22</a></div></div>
<div class="ttc" id="anamespacecheckLinks_html_a54e97434ff6ffa7352831fbf2a93c0c3"><div class="ttname"><a href="namespacecheckLinks.html#a54e97434ff6ffa7352831fbf2a93c0c3">checkLinks.ret</a></div><div class="ttdeci">ret</div><div class="ttdef"><b>Definition</b> <a href="checkLinks_8py_source.html#l00008">checkLinks.py:8</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md197"></a>
Receive (callback)</h2>
<div class="fragment"><div class="line"><span class="comment">// Callback receiver</span></div>
<div class="line">std::string uid = <span class="stringliteral">&quot;zyx&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// CB function</span></div>
<div class="line">std::function&lt;void(std::string)&gt; str_receiver_cb = [&amp;](std::string data) {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Str receiver callback called with data: &quot;</span> &lt;&lt; data &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> cbrec = IOManager::get()-&gt;get_receiver&lt;std::string&gt;(uid);</div>
<div class="line">cbrec-&gt;add_callback(str_receiver_cb);</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  got = cbrec-&gt;receive(timeout);</div>
<div class="line">} <span class="keywordflow">catch</span> (dunedaq::iomanager::ReceiveCallbackConflict&amp;) {</div>
<div class="line">  <span class="comment">// This is expected</span></div>
<div class="line">}</div>
<div class="line">IOManager::get()-&gt;remove_callback(uid);</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md198"></a>
When to use "try_" methods</h1>
<p>The standard <code>send()</code> and <code>receive()</code> methods will throw an ERS exception if they time out. This is ideal for cases where timeouts are an exceptional condition (this applies to most, if not all send calls, for example). In cases where the timeout condition can be safely ignored (such as the callback-driving methods which are retrying the receive in a tight loop), the <code>try_send</code> and <code>try_receive</code> methods may be used. Note that these methods are <b>not</b> <code>noexcept</code>, any non-timeout issues will result in an ERS exception.</p>
<h1><a class="anchor" id="autotoc_md199"></a>
Updating existing code to use IOManager</h1>
<p>Please see <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2iomanager_2docs_2Updating.html">this page</a> for information about updating your code to use IOManager. Also, if you are interested in using dynamic connection names, look at <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2iomanager_2docs_2Using-dynamic-connection-names.html">this page</a></p>
<h1><a class="anchor" id="autotoc_md200"></a>
APIs used by IOManager</h1>
<p>The API used for queues is documented <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2iomanager_2docs_2Queue.html">here</a>. Network connections use <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/ipm/">IPM</a> and <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2iomanager_2docs_2NetworkManager.html">NetworkManager</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 24 2024 for DUNE-DAQ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
