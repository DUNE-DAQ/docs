<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DUNE-DAQ: rawdatautils</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DUNE-DAQ
   </div>
   <div id="projectbrief">DUNE Trigger and Data Acquisition software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">rawdatautils</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md496"></a> </p>
<h1><a class="anchor" id="autotoc_md497"></a>
General Utilities</h1>
<h2><a class="anchor" id="autotoc_md498"></a>
&lt;tt&gt;file_quality_checker.py&lt;/tt&gt;</h2>
<p>Usage: </p><div class="fragment"><div class="line">file_quality_checker.py &lt;FILENAME1&gt; [FILENAME2 ...]</div>
</div><!-- fragment --><p>This script simply takes a list of HDF5 files produced by the DAQ (globs of course would work on the command line), loops over their records (whether trigger records or timeslices) and performs a few sanity checks. The output of the script when run on one file looks something like the following: </p><div class="fragment"><div class="line">Processing /data2/np04_hd_run018000_0009_dataflow0_datawriter_0_20221118T091751.hdf5.copied...</div>
<div class="line">Will process 27 trigger records.</div>
<div class="line">Processed 6 of 27 records...</div>
<div class="line">Processed 12 of 27 records...</div>
<div class="line">Processed 18 of 27 records...</div>
<div class="line">Processed 27 of 27 records...</div>
<div class="line"> </div>
<div class="line">Progression of record ids over records looks ok (expected change of 1 for each new record)</div>
<div class="line">Progression of sequence ids over records looks ok (expected change of 0 for each new record)</div>
<div class="line"> </div>
<div class="line"> FragType         |min # in rec|max # in rec|smallest (B)|largest (B)|min err in rec|max err in rec|</div>
<div class="line">----------------------------------------------------------------------------------------------------</div>
<div class="line">kWIB              |40          |40          |3866696     |3866696    |0             |0             |</div>
<div class="line">----------------------------------------------------------------------------------------------------</div>
<div class="line">kHardwareSignal   |1           |1           |96          |96         |1             |1             |</div>
<div class="line">----------------------------------------------------------------------------------------------------</div>
<div class="line">kTriggerCandidate |1           |1           |128         |128        |1             |1             |</div>
<div class="line">----------------------------------------------------------------------------------------------------</div>
</div><!-- fragment --><p> Concerning the progression of record ids and sequence ids: the script will look at the change in record id and sequence id between the first and second records in the file, and extrapolate that as the normal step size. If this step size is violated, then the full list of id values gets printed; otherwise simple one-sentence summaries such as you see above get printed.</p>
<p>Concerning the table: each row corresponds to a fragment type found in at least one record in the file. The first and second columns tell you the fewest instances of such a fragment found in a single record, and the most. Of course, these are typically the same value. The third and fourth columns tell you what the smallest and largest examples of this fragment were in the entire file. The fifth and sixth columns tell you the fewest instances of a fragment with a nonzero set of error bits, and the most, in a single record. Of course for these last two columns you'd ideally see all 0's.</p>
<h1><a class="anchor" id="autotoc_md499"></a>
WIB2 Utilities</h1>
<h2><a class="anchor" id="autotoc_md500"></a>
&lt;tt&gt;wib2decoder.py&lt;/tt&gt;</h2>
<div class="fragment"><div class="line">Usage: wib2decoder.py [OPTIONS] FILENAME</div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">  -n, --nrecords INTEGER  How many Trigger Records to process (default: all)</div>
<div class="line">  --nskip INTEGER         How many Trigger Records to skip (default: 0)</div>
<div class="line">  --channel-map TEXT      Channel map to load (default: None)</div>
<div class="line">  --print-headers         Print WIB2Frame headers</div>
<div class="line">  --print-adc-stats       Print ADC Pedestals/RMS</div>
<div class="line">  --check-timestamps      Check WIB2 Frame Timestamps</div>
<div class="line">  --help                  Show this message and exit.</div>
</div><!-- fragment --><p>For example, for HD coldbox data from v2.11 onward, you can do: </p><div class="fragment"><div class="line">wib2decoder.py -n 1 --print-headers --print-adc-stats --check-timestamps --channel-map HDColdboxChannelMap &lt;file_name&gt;</div>
</div><!-- fragment --><p> to dump content of the headers, do some timestamp checks for the frames coming from the same <a class="el" href="classWIB.html">WIB</a> and across different WIBs, and to do some basic processing of the data.</p>
<h1><a class="anchor" id="autotoc_md501"></a>
Unpack utilities for Python</h1>
<p>There are fast unpackers of data for working in python. These unpackers will take a Fragment and put the resulting values (ADCs or timestamps) in a numpy array with shape <code>(number of frames, number of channels)</code> at a similar speed compared to doing that in C++. This is much faster than doing a similar thing frame by frame in a loop in python.</p>
<p>To use it import the functions first: </p><div class="fragment"><div class="line">from rawdatautils.unpack.&lt;format&gt; import *</div>
</div><!-- fragment --><p> where <code>&lt;format&gt;</code> is one of the supported formats: <code>wib</code>, <code>wib2</code> or <code>daphne</code> for the corresponding <code>WIBFrame</code>, <code>WIB2Frame</code> and <code>DAPHNEFrame</code> frame formats. Then there are several functions available: </p><div class="fragment"><div class="line"># assumming frag is a fragment</div>
<div class="line">adc = np_array_adc(frag)</div>
<div class="line">timestamp = np.array_timestamp(frag)</div>
<div class="line">print(adc.shape)       # (number of frames in frag, 256 if using wib2)</div>
<div class="line">print(timestamp.shape) # (number of frames in frag, 256 if using wib2)</div>
</div><!-- fragment --><p> <code>np_array_adc</code> and <code>np_array_timestamp</code> will unpack the whole fragment. It is also possible to unpack only a part of it: </p><div class="fragment"><div class="line"># assumming frag is a fragment</div>
<div class="line">adc = np_array_adc_data(frag.get_data(), 100)             # first 100 frames</div>
<div class="line">timestamp = np_array_timestamp_data(frag.get_data(), 100) # first 100 frames</div>
<div class="line">print(adc.shape)       # (100, 256 if using wib2)</div>
<div class="line">print(timestamp.shape) # (100, 256 if using wib2)</div>
</div><!-- fragment --><p> Warning: <code>np_array_adc_data</code> and <code>np_array_timestamp_data</code> do not make any checks on the number of frames so if passed a value larger than the actual number of frames in the fragment it will try to read out of bounds. <code>np_array_adc</code> and <code>np_array_timestamp</code> call <code>np_array_adc_data</code> and <code>np_array_timestamp_data</code> under the hood with the correct checks on the number of frames.</p>
<h1><a class="anchor" id="autotoc_md502"></a>
File conversion</h1>
<p>It's possible to transform binary files using the old <code>WIBFrame</code> format to the newer <code>WIB2Frame</code> or <code>WIBEthFrame</code> format. That means that the ADC values will be preserved, as well as other values found in the header such as the crate, slot, fiber number. The timestamps will be overwritten to differ by 32 (by 32 * 64 for <code>WIBEthFrame</code>) to avoid warnings and other issues when these files are being read by readout. In python:</p>
<p>For <a class="el" href="classWIB.html">WIB</a> -&gt; WIB2 </p><div class="fragment"><div class="line">from rawdatautils import file_conversion</div>
<div class="line">file_conversion.wib_binary_to_wib2_binary(&#39;/path/to/input/file&#39;, &#39;/path/to/output/file&#39;)</div>
</div><!-- fragment --><p> and for <a class="el" href="classWIB.html">WIB</a> -&gt; WIBEth </p><div class="fragment"><div class="line">from rawdatautils import file_conversion</div>
<div class="line">file_conversion.wib_binary_to_wibeth_binary(&#39;/path/to/input/file&#39;, &#39;/path/to/output/file&#39;)</div>
</div><!-- fragment --><p>When transforming <a class="el" href="classWIB.html">WIB</a> -&gt; WIBEth it will create 4 files lblecause <code>WIBFrames</code> have 256 channels and <code>WIBEthFrames</code> have 64, so the first file has the first 64 channels, the second file has the next 64 channels and so on. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 24 2024 for DUNE-DAQ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
