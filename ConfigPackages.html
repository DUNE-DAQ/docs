<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DUNE-DAQ: Config Packages</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DUNE-DAQ
   </div>
   <div id="projectbrief">DUNE Trigger and Data Acquisition software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Config Packages</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The goal of the conffwk package is to provide user-friendly API to access data from the configuration database. There are two layers of such API which can be seen by user: </p><ul>
<li>abstract conffwk layer working with arbitrary database schema and hiding details of DBMS implementation </li>
<li>data access library (DAL), that is generated for given database schema to map it on programming language data types</li>
</ul>
<p>This page describes basics which a user should know to generate DAL from the database schema, to get data from database, to receive notification on their change, to create new data or to modify existing data using generated DAL.</p>
<ul>
<li><a class="el" href="ConfigPackages.html#SchemaDevelopment">1. Development of the configuration database schema</a> </li>
<li><a class="el" href="ConfigPackages.html#DalGeneration">2. Generation of the DAL</a> <ul>
<li>
<a class="el" href="ConfigPackages.html#GenconffwkParams">2.1. Parameters of genconffwk utility</a> </li>
<li>
<a class="el" href="ConfigPackages.html#CmakeIntegration">2.2. Integration with CMake</a> </li>
</ul>
</li>
<li><a class="el" href="ConfigPackages.html#ClassesAndMethods">3. DAL classes and methods</a> <ul>
<li>
<a class="el" href="ConfigPackages.html#TypesMapping">3.1. Mapping Between OKS Attribute Types and Programming Languages Types</a> </li>
</ul>
</li>
<li><a class="el" href="ConfigPackages.html#ErrorsHandling">4. Errors Handling</a> </li>
<li><a class="el" href="ConfigPackages.html#HowToGetData">5. How to get data</a> <ul>
<li>
<a class="el" href="ConfigPackages.html#HTGD_Initialisation">5.1. Initialization</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HTGD_ReadObjects">5.2. Read objects of class</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HTGD_ReadingAttributeValues">5.3. Reading Values of Attributes</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HTGD_ReadingRelationshipsValues">5.4. Reading Values of Relationships</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HTGD_CastClassTypes">5.5. Cast Class Types</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HTGD_DataDestruction">5.6. Data Destruction</a> </li>
</ul>
</li>
<li><a class="el" href="ConfigPackages.html#DataCreationAndModification">6. How to create and to modify data</a> <ul>
<li>
<a class="el" href="ConfigPackages.html#HCM_CreationDB">6.1. Creation of new database file</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HCM_DatabaseIncludes">6.2. Database Includes</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HCM_ObjectsManipulations">6.3. Objects Manipulations</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HCM_ModificationAttributeValues">6.4. Modification Values of Attributes</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HCM_ModificationRelationshipValues">6.5. Modification Values of Relationships</a> </li>
<li>
<a class="el" href="ConfigPackages.html#HCM_ModificationAndInvalidObjects">6.6. Modification of Database and Invalid Objects</a> </li>
</ul>
</li>
<li><a class="el" href="ConfigPackages.html#NotificationMechanism">7. Notification mechanism</a> <ul>
<li>
<a class="el" href="ConfigPackages.html#NM_UserCallback">7.1. User Callback</a> </li>
<li>
<a class="el" href="ConfigPackages.html#NM_SubscriptionCriteria">7.2. Subscription criteria</a> </li>
<li>
<a class="el" href="ConfigPackages.html#NM_Subscription">7.3. Subscription</a> </li>
</ul>
</li>
<li><a class="el" href="ConfigPackages.html#Algorithms">8. Algorithms</a> </li>
<li><a class="el" href="ConfigPackages.html#AdvancedCodeGeneration">9. Advanced Code Generation</a></li>
</ul>
<p>Sections 1, 2 and 3 are needed for those, who develops own schema and wants to generate DAL. Section 4 explain basics of error handling to be known by any user of DAL. Section 5 explain how to get data using DAL. Section 6 explains how to create or to modify data using DAL. Section 7 explains how to receive notification in case of data changes. The possibility to plug-in user algorithms to the generated DAL is described in section 8. Section 9 explains how to extend generated classes inserting user code.</p>
<h1><a class="anchor" id="SchemaDevelopment"></a>
1. Development of the configuration database schema</h1>
<p>It is possible to develop a new schema in case one needs to describe own configuration data which cannot be described by existing schemes. The development of the schema can be done using the OKS Schema Editor. There is a choice to extend the existing schemes or to develop own schema from scratch. To extend existing schema it is necessary to start the editor with it (which cannot be modified) and then to create the schema that can be updated, e.g.:</p>
<div class="fragment"><div class="line">oks_schema_editor dal/schema/core.schema.xml</div>
</div><!-- fragment --><p>The editor window with loaded schema will appear. Then it is possible to create own schema and to define own classes. To create a new schema from scratch, one just needs to run the editor without parameters and to create a new schema. For more information on the OKS schema editor, the OKS schema capabilities and exporting schema into different formats see OKS documentation. After the schema development is finished, it is necessary to save the schema into xml file and add it to the sources of some package. Such schema file will be used for the database data access library generation described by next section.</p>
<h1><a class="anchor" id="DalGeneration"></a>
2. Generation of the DAL</h1>
<p>A DAL is generated by the genconffwk utility. It uses OKS schema files as input and produces: </p><ul>
<li>C++ source files to build the library </li>
<li>C++ header files to describe library interface </li>
<li>C++ files to build binaries dumping content of the database </li>
<li>Java files to build jar file </li>
<li>genconffwk.info file containing information about names of generated classes, the C++ code namespace, include prefix directory and java package name</li>
</ul>
<h2><a class="anchor" id="GenconffwkParams"></a>
2.1. Parameters of genconffwk utility</h2>
<p>The command line parameters of genconffwk utility are listed below: </p><div class="fragment"><div class="line">genconffwk [-d | --C++-dir-name directory-name]</div>
<div class="line">          [-n | --C++-<span class="keyword">namespace </span>namespace</div>
<div class="line">          [-i | --C++-headers-dir directory-prefix]</div>
<div class="line">          [-j | --java-dir-name directory-name]</div>
<div class="line">          [-p | --java-package-name package-name]</div>
<div class="line">          [-I | --include-dirs dirs*]</div>
<div class="line">          [-c | --classes <span class="keyword">class</span>*]</div>
<div class="line">          [-D | --user-defined-classes [<span class="keyword">namespace</span>::]user-<span class="keyword">class</span>[@dir-pefix]*]</div>
<div class="line">          [-f | --info-file-name file-name]</div>
<div class="line">          [-v | --verbose]</div>
<div class="line">          [-h | --help]</div>
<div class="line">          -s | --schema-files file.schema.xml+</div>
<div class="line"> </div>
<div class="line">Options/Arguments:</div>
<div class="line">    -d directory-name    name of directory <span class="keywordflow">for</span> C++ header and implementation files</div>
<div class="line">    -n <span class="keyword">namespace         </span>namespace for C++ classes</div>
<div class="line">    -i directory-prefix  name of directory prefix for C++ header files</div>
<div class="line">    -j directory-name    name of directory for java files</div>
<div class="line">    -p package-name      package name for java files</div>
<div class="line">    -I dirs*             directories where to search <span class="keywordflow">for</span> already generated files</div>
<div class="line">    -c <span class="keyword">class</span>*            <span class="keyword">explicit</span> list of classes to be generated</div>
<div class="line">    -D [x::]c[@d]*       user-defined classes</div>
<div class="line">    -f <a class="code hl_enumvalue" href="ui__constants_8hpp.html#a034bcde91745657f16280ac4add0633ca435ed7e9f07f740abf511a62c00eef6e">filename</a>          name of output file describing generated files</div>
<div class="line">    -v                   <span class="keywordflow">switch</span> on verbose output</div>
<div class="line">    -h                   <span class="keyword">this</span> message</div>
<div class="line">    -s files+            the schema files (at least one is mandatory)</div>
<div class="ttc" id="aui__constants_8hpp_html_a034bcde91745657f16280ac4add0633ca435ed7e9f07f740abf511a62c00eef6e"><div class="ttname"><a href="ui__constants_8hpp.html#a034bcde91745657f16280ac4add0633ca435ed7e9f07f740abf511a62c00eef6e">tablepositions::filename</a></div><div class="ttdeci">@ filename</div></div>
</div><!-- fragment --><p>To generate a DAL it is necessary to provide name of the schema file. By default the DAL is generated for all classes contained in the schema files, otherwise one should provide names of required classes via &ndash;classes parameter. It is recommended to use unique namespace for each generated DAL to avoid possible problems when several DALs are used by one application.</p>
<p>It is possible to reuse already generated DALs. In this case one should to provide a list of directories containing information about already generated DALs via <code>--include-dirs</code> parameter, then to specify list of schema files and optionally to specify list of names of classes to be generated. It is expected such schema files use include statement for base schema files. The DAL is generated only for classes contained in the explicitly mentioned schema files, the classes from included files are ignored.</p>
<h2><a class="anchor" id="CmakeIntegration"></a>
2.2. Integration with CMake</h2>
<p>See CMake for ATLAS TDAQ Software <a href="https://twiki.cern.ch/twiki/bin/viewauth/Atlas/DaqHltCMake#DAL_Generation">TWiki page</a></p>
<p>The <code>tdaq_generate_dal()</code> command should be used to generate C++ and Java code from OKS schema files. The full signature looks like this:</p>
<div class="fragment"><div class="line">tdaq_generate_dal(schema_file...</div>
<div class="line">  NAMESPACE ns</div>
<div class="line">  [INCLUDE_DIRECTORIES ...]</div>
<div class="line">  [CLASSES ...]</div>
<div class="line">  [PACKAGE name]</div>
<div class="line">  [INCLUDE dir]</div>
<div class="line">  [NOINSTALL]</div>
<div class="line">  [CPP dir] [JAVA dir]</div>
<div class="line">  [CPP_OUTPUT var1] [JAVA_OUTPUT jvar2]</div>
<div class="line">  [DUMP_OUTPUT var2])</div>
</div><!-- fragment --><p>The command will generate the C++ and/or Java code and put the names of the generated files in the variables passed in the <code>CPP_OUTPUT</code> and <code>JAVA_OUTPUT</code> arguments respectively. Here is a simple use case:</p>
<div class="fragment"><div class="line">tdaq_generate_dal(data/schema/myclasses.schema.xml</div>
<div class="line">  NAMESPACE MyNamespace</div>
<div class="line">  INCLUDE_DIRECTORIES dal</div>
<div class="line">  INCLUDE DFConfiguration</div>
<div class="line">  CPP_OUTPUT dal_cpp_srcs)</div>
<div class="line"> </div>
<div class="line">  tdaq_add_library(mylib DAL ${dal_cpp_srcs})</div>
</div><!-- fragment --><p>This generates the C++ code for the classes in the schema file, using the namespace <code>MyNamespace</code> and referring to previously declared classes from the dal package. The header files will be installed into <code>include/DFConfiguration</code>. Note that the user doesn't have to know the names of the generated files. They are simply passed on to the library that uses them. In a similar way, the Java sources can be generated (typically using the <code>PACKAGE</code> argument to specify the generated package name. You can also generate the C++ and Java with a single command. The Java sources should be passed to the <code>tdaq_add_jar()</code> command.</p>
<p>If you want to build the generated dump command for this schema, specify the <code>DUMP_OUTPUT</code> variable which will contain the source file for the dump command. You can pass that to <code>tdaq_add_executable()</code>.</p>
<p>For both C++ and Java based libraries the DAL option should be specified when generated source files are used. This ensures that certain race conditions during the generation and the usage of the files are properly handled. The most common use case of having a single DAL and one or more libraries/jars using it is covered in this case.</p>
<p>If you are in the unusual situation that you generate more than one DAL in the same package, you have to do a bit more work: First pass the TARGET target_name parameter to <code>tdaq_generate_dal()</code>. It will uses this name instead of a default to represent the generation of the source files. Then use the <code>add_dependencies()</code> command to explicitly add dependencies between the DAL generation target and any consumers of the generated files. The internal target is the name you give, prefixes with DAL_. </p><div class="fragment"><div class="line">tdaq_generate_dal(TARGET dal1 schema/s1.schema.xml ...CPP_OUTPUT dal1_sources)</div>
<div class="line">tdaq_generate_dal(TARGET dal2 schema/s2.schema.xml ...CPP_OUTPUT dal2_sources)</div>
<div class="line"> </div>
<div class="line">tdaq_add_library(consumer1 ${dal1_sources})</div>
<div class="line">add_dependencies(consumer1 DAL_dal1)</div>
<div class="line"> </div>
<div class="line">tdaq_add_library(consumer2 ${dal2_sources})</div>
<div class="line">add_dependencies(consumer2 DAL_dal2)</div>
</div><!-- fragment --><p>You may not encounter any problems during development at all, especially if you don't do a highly parallel build. However, during the nightly builds we use all the cores of the machines we are running on, and if there are users in other packages of your library, the probability of race conditions increases.</p>
<h1><a class="anchor" id="ClassesAndMethods"></a>
3. DAL classes and methods</h1>
<p>For each OKS class appropriate DAL classes are generated: </p><ul>
<li>in case of C++ the generated class has the same name as OKS one and is declared inside namespace defined by the user; there is separate header file per each class; it has the same name as the database class and, to be included, it may have directory prefix, defined by user; if a class is derived from other classes, an appropriate C++ inheritance is used; </li>
<li>in case of Java there is interface which has the same name as the database class declared inside package with name provided by the user; the interface implementation is in the class with suffix <code>_Impl</code>; the static methods to get existent or to create new objects of the class are in the class with suffix <code>_Helper</code>; an appropriate inheritance is used between interfaces.</li>
</ul>
<p>For each direct attribute and relationship defined for OKS class the appropriate methods are generated. Such methods have the same names as the names of the attributes and the relationships in the database with <code>get_</code> and <code>set_</code> prefixes. The database attribute types are mapped to appropriate C++ and Java types. The multi-value attributes are mapped to <code>std::vector</code> of attribute type in C++ and to array of attribute type in Java. The database relationships are mapped to methods returning pointer or <code>std::vector</code> of pointers to objects of referenced class in C++ and similarly an object or array of objects in Java.</p>
<p>Additionally, for each class there are methods to get object's class name and object identity as they are defined in the database.</p>
<p>For C++ two <code>std::ostream</code> operators are generated for each class: </p><ul>
<li>the one with const reference to object prints out the full description of the object, and </li>
<li>the other one with const pointer to object prints out the object's class name and identity.</li>
</ul>
<p>In Java for each class there is generated method print() which prints out full description of the object.</p>
<p>When DAL is generated, any non-alphanumeric characters appeared in the names of classes, attributes, relationships and methods are replaced by underscore symbol, e.g. database attribute <code>"# of c++ lines"</code> will appear in DAL as <code>"__of_c___lines"</code>.</p>
<h2><a class="anchor" id="TypesMapping"></a>
3.1. Mapping Between OKS Attribute Types and Programming Languages Types</h2>
<p>Below there is map between OKS attribute types and C++/Java types: </p><table class="doxtable">
<tr>
<td>OKS Type </td><td>C++ type </td><td>Java type  </td></tr>
<tr>
<td>bool </td><td>bool </td><td>boolean  </td></tr>
<tr>
<td>s8 (8-bits signed integer) </td><td>int8_t </td><td>char  </td></tr>
<tr>
<td>u8 (8-bits unsigned integer) </td><td>uint8_t </td><td>byte  </td></tr>
<tr>
<td>s16 (16-bits signed integer) </td><td>int16_t </td><td>short  </td></tr>
<tr>
<td>u16 (16-bits unsigned integer) </td><td>uint16_t </td><td>short  </td></tr>
<tr>
<td>s32 (32-bits signed integer) </td><td>int32_t </td><td>int  </td></tr>
<tr>
<td>u32 (32-bits unsigned integer) </td><td>uint32_t </td><td>int<br  />
  </td></tr>
<tr>
<td>s64 (64-bits signed integer) </td><td>int64_t </td><td>long  </td></tr>
<tr>
<td>u64 (64-bits unsigned integer) </td><td>uint64_t </td><td>long  </td></tr>
<tr>
<td>float </td><td>float </td><td>float  </td></tr>
<tr>
<td>double </td><td>double </td><td>double  </td></tr>
<tr>
<td>date </td><td>std::string </td><td>java.lang.String  </td></tr>
<tr>
<td>time </td><td>std::string </td><td>java.lang.String  </td></tr>
<tr>
<td>string </td><td>std::string </td><td>java.lang.String  </td></tr>
<tr>
<td>enum </td><td>std::string </td><td>java.lang.String  </td></tr>
<tr>
<td>class </td><td>std::string </td><td>java.lang.String  </td></tr>
</table>
<p>In C++ the complex values (strings and vectors) are passed by const reference and not by value.s</p>
<h1><a class="anchor" id="ErrorsHandling"></a>
4. Errors Handling</h1>
<p>Methods of C++ and Java conffwk classes throw exceptions in case of errors.</p>
<p>C++ methods either have explicit <b>noexcept</b> specification if they may not throw an exception, or declare exception specification in doxygen documentation. The following exceptions can be thrown: </p><ul>
<li><code>daq::conffwk::Generic</code> is used to report most of the problems (bad DB, wrong parameter, plug-in specific, etc.) </li>
<li><code>daq::conffwk::NotFound</code> the conffwk object accessed by ID is not found, class accessed by name is not found </li>
<li><code>daq::conffwk::DeletedObject</code> accessing template object that has been deleted (via notification or by the user's code)</li>
</ul>
<p>All above exceptions have common class <code>daq::conffwk::Exception</code>, that can be used to catch all of them. </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// load database using oks file /tmp/mydb.data.xml</span></div>
<div class="line">  Configuration db(<span class="stringliteral">&quot;oksconflibs:/tmp/mydb.data.xml&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  ... <span class="comment">// user&#39;s code working with db</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (daq::conffwk::Exception &amp; ex) {</div>
<div class="line">    <span class="comment">// throw some user-defined exception in case of conffwk exception</span></div>
<div class="line">  <span class="keywordflow">throw</span> <a class="code hl_function" href="namespaceers.html#aff4eee77205a91301c3c942ae1de25c6">ers::error</a>(user::exception(<a class="code hl_define" href="LocalContext_8hpp.html#adea523c3dfceb9683f7acb5e719283ee">ERS_HERE</a>, <span class="stringliteral">&quot;cannot read conffwk&quot;</span>, ex));</div>
<div class="line">}</div>
<div class="ttc" id="aLocalContext_8hpp_html_adea523c3dfceb9683f7acb5e719283ee"><div class="ttname"><a href="LocalContext_8hpp.html#adea523c3dfceb9683f7acb5e719283ee">ERS_HERE</a></div><div class="ttdeci">#define ERS_HERE</div><div class="ttdef"><b>Definition</b> <a href="LocalContext_8hpp_source.html#l00130">LocalContext.hpp:130</a></div></div>
<div class="ttc" id="anamespaceers_html_aff4eee77205a91301c3c942ae1de25c6"><div class="ttname"><a href="namespaceers.html#aff4eee77205a91301c3c942ae1de25c6">ers::error</a></div><div class="ttdeci">void error(const Issue &amp;issue)</div><div class="ttdef"><b>Definition</b> <a href="ers_8hpp_source.html#l00081">ers.hpp:81</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="HowToGetData"></a>
5. How to get data</h1>
<p>The entry point to get data from database is the class Configuration defined in global namespace in C++ and in the conffwk package in Java. Below it is described how to create an object of this class and how to use it to get the database information.</p>
<h2><a class="anchor" id="HTGD_Initialisation"></a>
5.1. Initialization</h2>
<p>The <code>Configuration</code> constructors in both Java and C++ languages have single string parameter. If the parameter is an empty string, the constructor will use value of the <code>TDAQ_DB</code> environment variable. In case if both the constructor parameter and the environment variable are not set, or empty, then the configuration constructor throws <code>daq::conffwk::Generic</code> in case of C++, or <code>conffwk.SystemException</code> is thrown in case of Java.</p>
<p>The format of the parameter is <em>"name-of-plugin:plugin-parameters"</em>. The plug-in's parameter is optional. If it is non-empty, it is passed to the implementation plug-in constructor.</p>
<p>In C++ the name of plug-in is converted into name of the shared library by adding prefix <code>lib</code> and suffix <code></code>.so, e.g. <em>"oksconflibs"</em> plug-in name is converted into "liboksconflibs.so". The shared library must be in the path to shared libraries, e.g. in the LD_LIBRARY_PATH environment variable.</p>
<p>In Java the name of plug-in is converted into name of the class in package <em>"plugin-name"</em> with name created from <em>"plugin-name"</em>, where 1-st and 4-th characters are converted to upper case and <em>"uration"</em> string is appended (it is so by historical reasons), e.g. <em>"oksconflibs"</em> plug-in name is converted into <em>"oksconflibs.OksConfiguration"</em>. The CLASSPATH variable has to point to such class or jar file.</p>
<p>For the moment three implementation plug-ins are available: </p><ul>
<li>the <b>oksconflibs</b> using OKS implementation directly (i.e. reads XML files), </li>
<li>the read-only <b>roksconflibs</b> using OKS archive (oks2coral) (i.e. reads OKS data from Oracle archive), </li>
<li>the <b>rdbconffwk</b> accessing OKS with RDB server.</li>
</ul>
<h3><a class="anchor" id="HTGD_CppInitialisation"></a>
Details of initialization in C++ and examples</h3>
<p>Below there are examples of the Configuration constructor explicit parameters: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;conffwk/Configuration.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// example (1): load daq/partitions/be_test.data.xml file using oks</span></div>
<div class="line">  ::Configuration db1(<span class="stringliteral">&quot;oksconflibs:daq/partitions/be_test.data.xml&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// example (2): connect with server RDB using rdb implementation (in initial partition)</span></div>
<div class="line">  ::Configuration db2(<span class="stringliteral">&quot;rdbconffwk:RDB&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// example (2a): connect with server RDB using rdb implementation (in test partition)</span></div>
<div class="line">  ::Configuration db2a(<span class="stringliteral">&quot;rdbconffwk:test::RDB&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// example (2b): same as above using new style server-name@partition-name</span></div>
<div class="line">  ::Configuration db2b(<span class="stringliteral">&quot;rdbconffwk:RDB@test&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// example (3): use oks implementation and create new database</span></div>
<div class="line">  ::Configuration db3(<span class="stringliteral">&quot;oksconflibs&quot;</span>);</div>
<div class="line">  db3.create(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;/tmp/my.data.xml&quot;</span>, std::list&lt;std::string&gt;(1,<span class="stringliteral">&quot;/tmp/my.sch.xml&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// example (4): use rdb implementation and create new database</span></div>
<div class="line">    <span class="comment">//              on server RDB running in partition test</span></div>
<div class="line">  ::Configuration db4(<span class="stringliteral">&quot;rdbconffwk&quot;</span>);</div>
<div class="line">  db4.create(<span class="stringliteral">&quot;test::RDB&quot;</span>, <span class="stringliteral">&quot;/tmp/my.data.xml&quot;</span>, std::list&lt;std::string&gt;());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception&amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The recommended way is to get plug-in and it's parameter via environment variable. Most of the user's code for applications run by TDAQ's setup should to leave the parameter empty: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;conffwk/Configuration.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="oks__diff__data_8cxx.html#ac0f2228420376f4db7e1274f2b41667c">main</a>() {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    ::Configuration db(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    ERS_DEBUG( 1 , <span class="stringliteral">&quot;Read database &quot;</span> &lt;&lt; db.get_impl_spec())</div>
<div class="line">    db.get(...) <span class="comment">// any user&#39;s code working with Configuration object</span></div>
<div class="line">  }</div>
<div class="line">  catch(<a class="code hl_namespace" href="namespacedaq.html">daq</a>::<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>::Exception &amp; ex) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceconffwk_html"><div class="ttname"><a href="namespaceconffwk.html">conffwk</a></div><div class="ttdef"><b>Definition</b> <a href="conffwk_2python_2conffwk_2____init_____8py_source.html#l00001">__init__.py:1</a></div></div>
<div class="ttc" id="anamespacedaq_html"><div class="ttname"><a href="namespacedaq.html">daq</a></div><div class="ttdoc">Including ers headers.</div><div class="ttdef"><b>Definition</b> <a href="config__api__graph_8hpp_source.html#l00018">config_api_graph.hpp:19</a></div></div>
<div class="ttc" id="aoks__diff__data_8cxx_html_ac0f2228420376f4db7e1274f2b41667c"><div class="ttname"><a href="oks__diff__data_8cxx.html#ac0f2228420376f4db7e1274f2b41667c">main</a></div><div class="ttdeci">int main(int argc, const char *argv[])</div><div class="ttdef"><b>Definition</b> <a href="oks__diff__data_8cxx_source.html#l00149">oks_diff_data.cxx:149</a></div></div>
</div><!-- fragment --><p>In case it the parameter can be also passed via command line, use it as shown below: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;conffwk/Configuration.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="oks__diff__data_8cxx.html#ac0f2228420376f4db7e1274f2b41667c">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    ::Configuration db(argv[1]);</div>
<div class="line">    ERS_DEBUG( 1 , <span class="stringliteral">&quot;Read database &quot;</span> &lt;&lt; db.get_impl_spec())</div>
<div class="line">    db.get(...) <span class="comment">// any user&#39;s code working with Configuration object</span></div>
<div class="line">  }</div>
<div class="line">  catch(<a class="code hl_namespace" href="namespacedaq.html">daq</a>::<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>::Exception &amp; ex) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note, to get proper plug-in name and parameter used for configuration initialization (e.g. obtained via TDAQ_DB), use get_impl_spec() method of Configuration class, which is used in above examples for debug reporting.</p>
<h3><a class="anchor" id="HTGD_JavaInitialisation"></a>
Initialization in Java</h3>
<p>The Configuration constructor parameters are the same, as in case of C++. In case of problems the exception is thrown. An example is shown below: </p><div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  <a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>(<span class="stringliteral">&quot;rdbconffwk:RDB&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.SystemException ex) {</div>
<div class="line">  System.err.println( <span class="stringliteral">&quot;ERROR caught \&#39;conffwk.SystemException\&#39;:&quot;</span>);</div>
<div class="line">  System.err.println( <span class="stringliteral">&quot;*** &quot;</span> + ex.getMessage() + <span class="stringliteral">&quot; ***&quot;</span> );</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceconffwk_1_1Configuration_html"><div class="ttname"><a href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a></div><div class="ttdef"><b>Definition</b> <a href="Configuration_8py_source.html#l00001">Configuration.py:1</a></div></div>
</div><!-- fragment --><p>Note in case when rdb implementation is used, the partition name of the RDB server can be specified by several ways: </p><ul>
<li>using the same approach as for C++, i.e. via constructor parameter using double colon-separated partition and server names, e.g. <em>"rdbconffwk:partition-name::server-server"</em> or <em>"rdbconffwk:server-server@partition-name"</em>; </li>
<li>via <em>tdaq.ipc.partition.name</em> java virtual machine property, e.g. run java application with "-Dtdaq.ipc.partition.name=partition-name".</li>
</ul>
<h2><a class="anchor" id="HTGD_ReadObjects"></a>
5.2. Read objects of class</h2>
<p>Once an object of the Configuration class is successfully created, it can be used to get configuration data (i.e. objects). Normally to get configuration objects only C++ template methods of the Configuration class and generated Java code should be used. The usage of conffwk layer (i.e. direct usage of objects of ConfigObject class) only makes sense in few packages working with arbitrary database schemes.</p>
<p>For each generated class T two methods can be applied using configuration object: </p><ul>
<li>C++ template methods of the ::Configuration class: <ul>
<li>
<code> const T * Configuration::get(const std::string&amp;, bool, bool, unsigned long, const std::vector&lt;std::string&gt; *) </code> - to read named object; </li>
<li>
<code> void Configuration::get(std::vector&lt;const T*&gt;&amp;, bool, bool, const std::string&amp;, unsigned long rlevel, const std::vector&lt;std::string&gt; *) </code> - to read objects of class; </li>
</ul>
</li>
<li>Java methods generated in class T_Helper: <ul>
<li>
static public T get(<a class="el" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db, String id) to read named object </li>
<li>
static public T[] gets(<a class="el" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db, Query query) to read objects of class </li>
</ul>
</li>
</ul>
<p>The methods looking for single object by identity and methods looking for objects of class in case if the query string is empty are searching objects in the class and all it's subclasses, e.g. if class B is derived from class A, then the second method used for class A returns all objects of class A and all objects of class B, and the first method used for class A is looking for object with given identity in class A and then in class B. The same methods used for class B are only looking for objects of class B.</p>
<p>If the query is non-empty, the methods filling vectors of objects only return objects satisfying the query criteria. A query can be an OKS query string. It can be created by the OKS Data Editor or written by hand as described by the OKS documentation , e.g.: </p><ul>
<li><em> (all ("Name" "my-object" =)) </em> - search all objects of class T and it's subclasses which name is equal to "my-object"; </li>
<li><em> (this (and ("Address" 128 &gt;=) ("Address" 256 &lt;))) </em> - search all objects of class T which address is equal or greater than 128 and less than 256; </li>
<li><em> (this ("Modules" all ("State" 0 =))) </em> - search all objects of class T which has objects referenced via relationship "Modules" with attribute "State" set to 0.</li>
</ul>
<h3><a class="anchor" id="HTGD_OnlineDalCppExample"></a>
C++ Example (using online dal package)</h3>
<p>To read all applications via C++ dal provided by the online software one can write: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;conffwk/ConfigObject.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;conffwk/Configuration.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;dal/Application.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  ::Configuration db(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <span class="comment">// &#39;objects&#39; vector contains Applications and all objects from derived classes,</span></div>
<div class="line">    <span class="comment">// e.g. RunControlApplications, etc.</span></div>
<div class="line">  std::vector&lt;const dal::Application *&gt; objects;</div>
<div class="line">  db.get(objects);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To get only run control applications it is possible to use the following code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;dal/RunControlApplication.h&gt;</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  ::Configuration db(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">  std::vector&lt;const dal::RunControlApplication *&gt; objects;</div>
<div class="line">  db.get(objects);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note, to get a named object it is necessary to use template parameter explicitly and to write: </p><div class="fragment"><div class="line"><span class="keyword">const</span> dal::Application * a = db.get&lt;dal::Application&gt;(<span class="stringliteral">&quot;my-application&quot;</span>);</div>
</div><!-- fragment --><p>instead of </p><div class="fragment"><div class="line"><span class="keyword">const</span> dal::Application * a = db.get(<span class="stringliteral">&quot;my-application&quot;</span>); <span class="comment">// COMPILATION ERROR!</span></div>
</div><!-- fragment --><p>When the methods parameter <code>init_children</code> is set to <b>true</b>, all objects referenced by the retrieved objects are also read and initialized (i.e. values of their attributes are read from database and all referenced objects are also recursively read). Otherwise the referenced objects can only be pre-allocated (if they were not already read explicitly) and the actual reading will happen, when the user will apply a method to read values of their attributes or relationships.</p>
<p>When the methods parameter <code>init_object</code> is set to <b>false</b>, all retrieved objects are only pre-allocated without reading their attributes and relationships. The values of attributes and relationships will actually be read from database implementation, when the user will apply a method to read an attribute or relationship value.</p>
<p>The above two parameters can be used by the user to improve performance. For example, if the parameter <code>init_children</code> is set to <b>false</b>, the only objects which are really used by the user process will be read from the database. However in this case the database can not be closed (e.g. to free used resources) until the configuration data are used. Also, the actual read from database can happen at an unexpected moment, that can introduce undesired delays.</p>
<h3><a class="anchor" id="HTGD_JavaExample"></a>
Java Example (online DAL)</h3>
<p>To read all applications via Java dal provided by the online software one can write: </p><div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>;</div>
<div class="line"><span class="keyword">import</span> dal.Application;</div>
<div class="line"><span class="keyword">import</span> dal.Application_Helper;</div>
<div class="line">...</div>
<div class="line">conffwk.<a class="code hl_class" href="classconffwk_1_1Configuration_1_1Configuration.html">Configuration</a> db = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>(...);</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  dal.Application objs[] = dal.Application_Helper.get(db, <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.Query());</div>
<div class="line">} <span class="keywordflow">catch</span> ( <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.NotFoundException ex ) {</div>
<div class="line">  System.err.println(<span class="stringliteral">&quot;ERROR: bad query or no such class loaded&quot;</span>);</div>
<div class="line">} <span class="keywordflow">catch</span> ( <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.SystemException ex ) {</div>
<div class="line">  System.err.println(<span class="stringliteral">&quot;ERROR: caught system exception&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassconffwk_1_1Configuration_1_1Configuration_html"><div class="ttname"><a href="classconffwk_1_1Configuration_1_1Configuration.html">conffwk.Configuration.Configuration</a></div><div class="ttdef"><b>Definition</b> <a href="Configuration_8py_source.html#l00024">Configuration.py:24</a></div></div>
</div><!-- fragment --><p>To get only run control applications it is possible to write (try/catch statements are skipped): </p><div class="fragment"><div class="line"><span class="keyword">import</span> dal.RunControlApplication;</div>
<div class="line"><span class="keyword">import</span> dal.RunControlApplication_Helper;</div>
<div class="line">...</div>
<div class="line">dal.RunControlApplication objs[] = dal.RunControlApplication_Helper.get(db, <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.Query());</div>
</div><!-- fragment --><p>Below there is an example of code to get an application by ID. Note, if object with such ID does not exist, conffwk.NotFoundException exception is thrown. </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  dal.Application obj = dal.Application_Helper.get(db, <span class="stringliteral">&quot;RootController&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.NotFoundException e) {</div>
<div class="line">  System.err.println( <span class="stringliteral">&quot;ERROR: can not find application \&#39;RootController\&#39;&quot;</span> );</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="HTGD_ReadingAttributeValues"></a>
5.3. Reading Values of Attributes</h2>
<p>Once the objects are retrieved, the user can get values of their attributes. A method to read attribute value is created for each attribute of each generated class. It has the following format: </p><ul>
<li>for C++: <ul>
<li>
<code> type get_AttributeName() const </code> - for single-value integer and float numbers; </li>
<li>
<code> const std::string&amp; get_AttributeName() const </code> - for single-value string-based attributes; </li>
<li>
<code> const std::vector&lt;type&gt;&amp; get_AttributeName() const </code> - for multi-value attributes; </li>
</ul>
</li>
<li>for Java: <ul>
<li>
<code> type get_AttributeName() const </code> - for single-value attributes; </li>
<li>
<code> type[] get_AttributeName() const </code> - for multi-value attributes. </li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="HTGD_AttributeConverters"></a>
Attribute Converters</h3>
<p>The user can use one or several ways to convert values of all attributes of a C++ or Java type. To do this he/she needs to implement or to use already existing converter class, to create converter object of that class and to pass such object to the Configuration object using method Configuration::register_converter().</p>
<p>In case of C++ such class has to inherit from the template Configuration::AttributeConverter &lt; T &gt; class, where template parameter T defines type of attributes which values need to be converted and to implement virtual method Configuration::AttributeConverter::convert(), that performs the real conversion of attribute values.</p>
<dl class="section note"><dt>Note</dt><dd>The C++ converter object is destroyed by the configuration destructor. User must not call <code>delete</code> on the attribute converter object.</dd></dl>
<p>In case of Java a converter class has to implement conffwk.AttributeConverter interface defining two methods: the method convert() as in C++ and the method get_class(), which returns class of converted attributes.</p>
<p>Below there is C++ example of user functions converting string and integer attributes: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;conffwk/Configuration.h&gt;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// converter to replace by &#39;_&#39; a non-alpha-numeric symbol in db strings</span></div>
<div class="line"><span class="keyword">class </span>GoodString : <span class="keyword">public</span> ::Configuration::AttributeConverter&lt;std::string&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">char</span> <a class="code hl_function" href="utils_8cpp.html#a7c629429ca7502a6ad45b6031b179cbb">cvt_symbol</a>(<span class="keywordtype">char</span> c) { <span class="keywordflow">return</span> (isalnum(c) ? c : <span class="stringliteral">&#39;_&#39;</span>); }</div>
<div class="line">  <span class="keywordtype">void</span> convert(std::string&amp; s, <span class="keyword">const</span> Configuration&amp;, <span class="keyword">const</span> ConfigObject&amp;, <span class="keyword">const</span> std::string&amp;) {</div>
<div class="line">    std::transform(s.begin(), s.end(), s.begin(), <a class="code hl_function" href="utils_8cpp.html#a7c629429ca7502a6ad45b6031b179cbb">cvt_symbol</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">  <span class="comment">// converter to make any long integer value positive</span></div>
<div class="line"><span class="keyword">class </span>PositiveInt : <span class="keyword">public</span> ::Configuration::AttributeConverter&lt;unsigned long&gt; {</div>
<div class="line">  <span class="keywordtype">void</span> convert(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&amp; i, <span class="keyword">const</span> Configuration&amp;, <span class="keyword">const</span> ConfigObject&amp;, <span class="keyword">const</span> std::string&amp;) {</div>
<div class="line">    <span class="keywordflow">if</span>(i &lt; 0) i = -i;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">try {</div>
<div class="line">  ::Configuration db(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">  db.register_converter(<span class="keyword">new</span> GoodString());</div>
<div class="line">  db.register_converter(<span class="keyword">new</span> PositiveInt());</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="ttc" id="autils_8cpp_html_a7c629429ca7502a6ad45b6031b179cbb"><div class="ttname"><a href="utils_8cpp.html#a7c629429ca7502a6ad45b6031b179cbb">cvt_symbol</a></div><div class="ttdeci">char cvt_symbol(char c)</div><div class="ttdef"><b>Definition</b> <a href="utils_8cpp_source.html#l00026">utils.cpp:26</a></div></div>
</div><!-- fragment --><p>In the Java an example of Java code is shown below: </p><div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>;</div>
<div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.AttributeConverter;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// converter removes leading and trailing whitespace from a string</span></div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>TrimString <span class="keyword">implements</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.AttributeConverter {</div>
<div class="line">  <span class="keyword">public</span> Object convert(Object s, <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a> db, <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1ConfigObject.html">ConfigObject</a> obj, String attr_name) { <span class="keywordflow">return</span> (Object)(s.trim()); }</div>
<div class="line">  <span class="keyword">public</span> Class get_class() { <span class="keywordflow">return</span> String.class; }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">conffwk.Configuration db = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">db.register_converter(<span class="keyword">new</span> TrimString());</div>
<div class="ttc" id="anamespaceconffwk_1_1ConfigObject_html"><div class="ttname"><a href="namespaceconffwk_1_1ConfigObject.html">conffwk.ConfigObject</a></div><div class="ttdef"><b>Definition</b> <a href="ConfigObject_8py_source.html#l00001">ConfigObject.py:1</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="HTGD_OnlineDalConverters"></a>
Online DAL Converters</h3>
<p>The core TDAQ C++ DAL (libdaq-core-dal.so) provides converter daq::core::SubstituteVariables class to substitute configuration parameters in values of string attributes. It's constructor requires Configuration object and Partition object, since they are used to calculate conversion map. In case, if configuration database is reloaded, such parameters have to be reset using reset() method. An example of the C++ code is shown below: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;conffwk/Configuration.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;dal/Partition.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;dal/util.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  ::Configuration db(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">const</span> daq::core::Partition * p = daq::core::get_partition(db, <span class="stringliteral">&quot;partition-X&quot;</span>)) {</div>
<div class="line">    db.register_converter(<span class="keyword">new</span> daq::core::SubstituteVariables(db, *p));</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Similar Java dal.jar provides attribute converter in the same way. An example of it's usage is shown below: </p><div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>;</div>
<div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.DalObject;</div>
<div class="line"><span class="keyword">import</span> dal.SubstituteVariables;</div>
<div class="line"><span class="keyword">import</span> dal.Partition;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">dal.Partition p = dal.Algorithms.get_partition(db, <span class="stringliteral">&quot;partition-X&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(p != <span class="keyword">null</span>) {</div>
<div class="line">  db.register_converter(<span class="keyword">new</span> dal.SubstituteVariables(db, p));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="HTGD_ReadingRelationshipsValues"></a>
5.4. Reading Values of Relationships</h2>
<p>Once an object is retrieved, the user can get objects referenced by it. A method is created for each relationship of each generated class. It has the following format: </p><ul>
<li>for C++: <ul>
<li>
<code> const class-type * get_RelationshipName() const </code> - for single-value relationships; </li>
<li>
<code> const std::vector&lt;const class-type*&gt;&amp; get_RelationshipName() const </code> - for multi-value relationships; </li>
</ul>
</li>
<li>for Java: <ul>
<li>
<code> class-type get_RelationshipName() const </code> - for single-value relationships; </li>
<li>
<code> class-type[] get_RelationshipName() const </code> - for multi-value relationships. </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="HTGD_CastClassTypes"></a>
5.5. Cast Class Types</h2>
<p>There are situations when user may need to cast an object from one class to a derived one. To make a down cast for an object of generated class the user should to use the methods of the configuration classes and never use cast supported by the programming languages.</p>
<h3><a class="anchor" id="HTGD_CppCast"></a>
C++ cast</h3>
<p>There are situations when some set of objects can belong to different classes, e.g. objects can be of class A or B which is derived from class A. For a down cast the ::Configuration::cast() method must be used. As an example, the code to try and to cast from application to run-control application type is shown below: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// some code to get the vector of applications</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;const dal::Application*&gt;&amp; l = ...;</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; j : l) {</div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keyword">const</span> dal::RunControlApplication * r = j-&gt;cast&lt;dal::RunControlApplication&gt;()) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;application &quot;</span> &lt;&lt; r &lt;&lt; <span class="stringliteral">&quot; is run control application&quot;</span> &lt;&lt; std::endl; </div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="HTGD_JavaCast"></a>
Java cast</h3>
<p>To down cast an object of generated Java DAL use appropriate cast() method in generated class. For example, some object of application class can be down casted to the run control application: </p><div class="fragment"><div class="line">dal.Application a = ...; <span class="comment">// some code to get application</span></div>
<div class="line">dal.RunControlApplication rc_application = dal.RunControlApplication_Helper.cast(a);</div>
<div class="line"><span class="keywordflow">if</span>(rc_application != <span class="keyword">null</span>) { ... }</div>
</div><!-- fragment --><h2><a class="anchor" id="HTGD_DataDestruction"></a>
5.6. Data Destruction</h2>
<p>In C++ the object of the ::Configuration class should not be destroyed while the DAL is in use. All objects read via template methods are destroyed by the ::Configuration class destructor. The user must never try to modify or to destroy such objects himself.</p>
<h1><a class="anchor" id="DataCreationAndModification"></a>
6. How to create and to modify data</h1>
<p>This section explains how to create a new database file, how to create or remove database data and how to modify existing data.</p>
<p>Any modifications described by this section becomes persistent and visible to others processes only after successful <b>commit</b> operation. If the modification should not be committed (e.g. a modification failed), it is necessary to execute abort operation, e.g. in C++: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  ::Configuration db();</div>
<div class="line">  <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;</div>
<div class="line">  ... <span class="comment">// some code which makes changes and sets the variable to false if failed</span></div>
<div class="line">  <span class="keywordflow">if</span>(success) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;commit changes\n&quot;</span>;</div>
<div class="line">    db.commit();  <span class="comment">// one also check return status, true means success</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: something was wrong, roll back changes\n&quot;</span>;</div>
<div class="line">    db.abort();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Below there is the same example for Java: </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>(...);</div>
<div class="line">... <span class="comment">// some code to makes changes and sets the success variable to false if failed</span></div>
<div class="line"><span class="keywordflow">if</span>(success) {</div>
<div class="line">  System.out.println(<span class="stringliteral">&quot;commit changes&quot;</span>);</div>
<div class="line">  db.commit();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">  System.err.println(<span class="stringliteral">&quot;ERROR: something was wrong, roll back changes&quot;</span>);</div>
<div class="line">  db.abort();</div>
<div class="line">}</div>
</div><!-- fragment --><p>To modify or to destroy an object using generated C++ DAL methods described below, it is necessary to have a non-const pointer or reference on the object. However all generated DAL methods return objects as const. To make a change it is necessary to use C++ <code>const_cast</code> to get non-const pointer or reference.</p>
<h2><a class="anchor" id="HCM_CreationDB"></a>
6.1. Creation of new database file</h2>
<p>To create a new database file using C++ it is necessary to build an object of the ::Configuration class only providing name of implementation plug-in: </p><div class="fragment"><div class="line">::Configuration db(<span class="stringliteral">&quot;oksconflibs&quot;</span>);</div>
</div><!-- fragment --><p>Similar code for Java is below: </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>(<span class="stringliteral">&quot;rdbconffwk&quot;</span>); <span class="comment">// no db file</span></div>
</div><!-- fragment --><p>To create a new database data file it is necessary to decide which schema (at least one schema is always required) and optionally others database files will be used. Then it is necessary to provide an absolute name for newly created database file (the user should have write permission or the rdb server must be run in read-write mode under account which has such rights). If rdb implementation is used, it is also necessary to provide server and optionally partition name. After this it is necessary to use create method of the ::Configuration class and check it's return status.</p>
<p>Below there is example for C++ and oks implementation: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  ::Configuration db(<span class="stringliteral">&quot;oksconflibs&quot;</span>);</div>
<div class="line">  std::list&lt;std::string&gt; includes;</div>
<div class="line">  includes.push_back(<span class="stringliteral">&quot;online/schema/online.schema.xml&quot;</span>); <span class="comment">// common schema</span></div>
<div class="line">  includes.push_back(<span class="stringliteral">&quot;online/segments/setup.data.xml&quot;</span>);  <span class="comment">// online infrastructure</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> * db_name = <span class="stringliteral">&quot;/tmp/my-partition.data.xml&quot;</span>;   <span class="comment">// new database file name</span></div>
<div class="line">  <span class="keywordflow">if</span>(db.create(<span class="stringliteral">&quot;&quot;</span>, db_name, includes) == <span class="keyword">false</span>) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: failed to create file &quot;</span> &lt;&lt; db_name &lt;&lt; std::endl;</div>
<div class="line">    db.abort();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For rdb implementation it is similar, but requires rdb server and optionally partition's names: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  ::Configuration db(<span class="stringliteral">&quot;rdbconffwk&quot;</span>);</div>
<div class="line">  std::list&lt;std::string&gt; includes;</div>
<div class="line">  includes.push_back(<span class="stringliteral">&quot;online/schema/online.schema.xml&quot;</span>); <span class="comment">// common schema</span></div>
<div class="line">  includes.push_back(<span class="stringliteral">&quot;online/segments/setup.data.xml&quot;</span>);  <span class="comment">// online infrastructure</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> * db_name = <span class="stringliteral">&quot;/tmp/my-partition.data.xml&quot;</span>;   <span class="comment">// new database file name</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> * server_name = <span class="stringliteral">&quot;foo::bar&quot;</span>;                 <span class="comment">// server with name bar running in part. foo</span></div>
<div class="line">  <span class="keywordflow">if</span>(db.create(server_name, db_name, includes) == <span class="keyword">false</span>) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: failed to create file &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="stringliteral">&quot; on &quot;</span> &lt;&lt; server_name &lt;&lt; std::endl;</div>
<div class="line">    db.abort();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For Java an example with rdb implementation is shown below: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  <a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>(<span class="stringliteral">&quot;rdbconffwk&quot;</span>);</div>
<div class="line">  String[] includes = <span class="keyword">new</span> String[2];</div>
<div class="line">  includes[0] = <span class="stringliteral">&quot;online/schema/online.schema.xml&quot;</span>; <span class="comment">// common schema</span></div>
<div class="line">  includes[1] = <span class="stringliteral">&quot;online/segments/setup.data.xml&quot;</span>;  <span class="comment">// online infrastructure</span></div>
<div class="line">  db.create(<span class="stringliteral">&quot;foo::bar&quot;</span>, <span class="stringliteral">&quot;/tmp/my-partition.data.xml&quot;</span>, includes);</div>
<div class="line">  db.commit();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.SystemException ex) {</div>
<div class="line">  System.err.println(<span class="stringliteral">&quot;ERROR: caught \&#39;conffwk.System\&#39; exception&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.NotAllowedException ex) {</div>
<div class="line">  System.err.println(<span class="stringliteral">&quot;ERROR: caught \&#39;conffwk.NotAllowed\&#39; exception&quot;</span>);</div>
<div class="line">}</div>
<div class="line">... <span class="comment">// catch conffwk.AlreadyExistsException in a similar way</span></div>
</div><!-- fragment --><p>The included files should exist in advance and be defined either as an absolute path or as a relative path to a token of the TDAQ_DB_PATH variable value.</p>
<h2><a class="anchor" id="HCM_DatabaseIncludes"></a>
6.2. Database Includes</h2>
<p>There are methods in C++ class ::Configuration to add a new include, to remove an existing include or to get list of includes for given database. They are: </p><ul>
<li><code> bool Configuration::add_include(const std::string&amp; db_name, const std::string&amp; include) </code> - adds include to the database db_name and returns true in case of success or false if failed; </li>
<li><code> bool Configuration::remove_include(const std::string&amp; db_name, const std::string&amp; include) </code> - removes an existing include from the database db_name and returns true in case of success or false if failed; </li>
<li><code> bool Configuration::get_includes(const std::string&amp; db_name, std::list&lt;std::string&gt;&amp; includes) const </code> - fills list of includes by files which are included by the db_name and returns true in case of success or false if failed.</li>
</ul>
<p>Similar methods in Java class <a class="el" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> are: </p><ul>
<li><code> void add_include(String db_name, String include) </code> - adds include to the database db_name or throws exception if failed; </li>
<li><code> void remove_include(String db_name, String include) </code> - removes an existing include from the database db_name or throws exception if failed; </li>
<li><code> void get_includes(String db_name, String[] includes) </code> - fills array of includes by files which are included by the db_name or throws exception if failed.</li>
</ul>
<h2><a class="anchor" id="HCM_ObjectsManipulations"></a>
6.3. Objects Manipulations</h2>
<p>This subsection explains how to create and how to destroy database objects.</p>
<h3><a class="anchor" id="HCM_ObjectsCreation"></a>
Objects Creation</h3>
<p>To create a new object using generated C++ DAL there are two ::Configuration template methods: </p><ul>
<li><code> const T * Configuration::create(const std::string&amp; at, const std::string&amp; id, bool) </code> - to create new object of class T with identity id at existing database file with name at; </li>
<li><code> const T * Configuration::create(const ::DalObject&amp; at, const std::string&amp; id, bool) </code> - to create new object of class T with identity id at a database file where object at is stored.</li>
</ul>
<p>The methods return non-null pointer in case of success or null if failed. The second method is faster since time to search the database file where to put new object is much smaller.</p>
<p>When the <code>init_object</code> parameter is set to false, then the values of attributes and relationships are not read from implementation (for a newly created object they are set to default values in accordance with the database schema).</p>
<p>An example how to create two new objects of the online dal::Computer class is shown below: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  ::Configuration db(...);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> * dbfile = <span class="stringliteral">&quot;/tmp/my-db.data.xml&quot;</span>;</div>
<div class="line">  <span class="keyword">const</span> dal::Computer * host = db.create&lt;dal::Computer&gt;(dbfile, <span class="stringliteral">&quot;host-1&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span>(host == 0) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: failed to create object \&#39;host-1\&#39; at \&#39;&quot;</span> &lt;&lt; dbfile &lt;&lt; <span class="stringliteral">&quot;\&#39;\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span>(db.create&lt;dal::Computer&gt;(*host, <span class="stringliteral">&quot;host-2&quot;</span>) == 0) {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: failed to create object \&#39;host-2\&#39; at file of &quot;</span> &lt;&lt; host;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>On Java similar methods are genereted in the helper classes. For class T two methods are available: </p><ul>
<li><code> T create(<a class="el" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db, String at, String id) </code> - to create new object of class T with identity id at existing database file with name at; </li>
<li><code> T create(<a class="el" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db, conffwk.DalObject at, String id) </code> - to create new object of class T with identity id at a database file where object at is stored.</li>
</ul>
<p>The example to create online segment and it's application is shown below:: </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db = <span class="keyword">new</span> ...</div>
<div class="line">String db_file = <span class="stringliteral">&quot;/tmp/my-db.data.xml&quot;</span>;</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  dal.Segment s = dal.Segment_Helper.create(db, db_file, <span class="stringliteral">&quot;my segment&quot;</span>);</div>
<div class="line">  dal.Application a = dal.Application_Helper.create(db, s, <span class="stringliteral">&quot;my application&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.SystemException ex) {</div>
<div class="line">  System.err.println(<span class="stringliteral">&quot;ERROR: caught \&#39;conffwk.System\&#39; exception&quot;</span>);</div>
<div class="line">} ... <span class="comment">// also other exceptions to be caught</span></div>
</div><!-- fragment --><h3><a class="anchor" id="HCM_ObjectsDestruction"></a>
Objects Destruction</h3>
<p>To destroy an existing object there is template method in the C++ ::Configuration class bool destroy(T&amp; obj). It returns true in case of success and false if failed. See example: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  ::Configuration db(...);</div>
<div class="line">  dal::Computer * host = ...; <span class="comment">// some code to get pointer</span></div>
<div class="line">  db.destroy(*host);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In Java the method void destroy(<a class="el" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db) is generated in T.java, e.g.: </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db = <span class="keyword">new</span> ...;</div>
<div class="line">dal.Computer host = ...; <span class="comment">// some code to get object</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  host.destroy(db);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.SystemException ex) {</div>
<div class="line">  System.err.println(<span class="stringliteral">&quot;ERROR: failed to destroy &quot;</span> + host);</div>
<div class="line">} ... <span class="comment">// also other exceptions to be caught</span></div>
</div><!-- fragment --><h2><a class="anchor" id="HCM_ModificationAttributeValues"></a>
6.4. Modification Values of Attributes</h2>
<p>Once the objects are retrieved or created, the user can modify values of their attributes. A method to set attribute value is created for each attribute of each generated class. The mapping between C++/Java types and OKS types can be seen in the <a class="el" href="ConfigPackages.html#TypesMapping">3.1. Mapping Between OKS Attribute Types and Programming Languages Types</a> section.</p>
<p>In C++ such method throws daq::conffwk::Exception if failed: </p><ul>
<li><code> void set_AttributeName(type value) </code> - for single-value attribute; </li>
<li><code> void set_AttributeName(const std::vector&lt;type&gt;&amp; value) </code> - for multi-value attribute.</li>
</ul>
<p>In Java such method throws an exception if failed: </p><ul>
<li><code> void set_AttributeName(type value) </code> - for single-value attribute; </li>
<li><code> void set_AttributeName(type[] value) </code> - for multi-value attribute.</li>
</ul>
<h2><a class="anchor" id="HCM_ModificationRelationshipValues"></a>
6.5. Modification Values of Relationships</h2>
<p>Once the objects are retrieved or created, the user can modify values of their relationships. A method to set relationship value is created for each relationship of each generated class.</p>
<p>For C++ it has the following format and throws daq::conffwk::Exception if failed: </p><ul>
<li><code> void set_RelationshipName(const class-type * value) </code> - for single-value relationships; </li>
<li><code> void set_RelationshipName(const std::vector&lt;const class-type*&gt;&amp; value) </code> - for multi-value relationships.</li>
</ul>
<p>For Java it has the following format and throws an exception if failed: </p><ul>
<li><code> void set_RelationshipName(class-type value) </code> - for single-value relationships; </li>
<li><code> void set_RelationshipName(class-type[] value) </code> - for multi-value relationships.</li>
</ul>
<h2><a class="anchor" id="HCM_ModificationAndInvalidObjects"></a>
6.6. Modification of Database and Invalid Objects</h2>
<p>There are several methods which may make instances of ConfigObject and generated DAL classes be invalid: </p><ul>
<li>Configuration::remove_include(const std::string&amp;, const std::string&amp;) - this method destroys objects belonging to files closed in result of include removal; </li>
<li>Configuration::destroy_obj(ConfigObject&amp;) and template Configuration::destroy(T&amp;) - those methods destroy given object and may destroy other objects linked via composite dependent relationships.</li>
</ul>
<p>In case of ConfigObject there is no simple way to know if an object is valid after above remove_include() or destroy_obj() method call, since by efficiency reasons all methods are redirected to implementation object without checking of it's validity. It is recommended to reinitialize all instances of ConfigObject after above calls.</p>
<p>With objects of generated DAL classes the situation is different. After implementation object destruction a method invoked on corresponding DAL objects will throw daq::conffwk::DeletedObject exception, that can be caught by user code. Also, validity of object can be tested with DalObject::was_removed() method.</p>
<p>An example is shown below for include file removal and exception mechanism for generated DAL objects: </p><div class="fragment"><div class="line">Configuration db;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">std::vector&lt;<span class="keyword">const</span> daq::core::Computer*&gt; nodes;</div>
<div class="line">db.get(nodes);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// remove include &quot;bar&quot; from file &quot;foo&quot;,</span></div>
<div class="line">  <span class="comment">// that may result some files to be closed</span></div>
<div class="line">  <span class="comment">// and several template objects to be invalidated</span></div>
<div class="line"> </div>
<div class="line">db.remove_include(<span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; i : nodes) {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    i-&gt;get_State();  <span class="comment">// cause exception if object was destroyed</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;object &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; was not destroyed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(<span class="keyword">const</span> daq::conffwk::DeletedObject&amp;) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Oops, object &quot;</span> &lt;&lt; (<span class="keywordtype">void</span> *)i &lt;&lt; <span class="stringliteral">&quot; was destroyed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="NotificationMechanism"></a>
7. Notification mechanism</h1>
<p>The user application can be notified on changes of the configuration data. To do this user should to implement one or many callback functions (C++) or classes (Java) which will be used when the database changes are committed and to choose which changes in classes and objects should be reported (i.e. to define <em> the subscription criteria </em>).</p>
<p>The user receives description of information changes in one go via callbacks invoked after commit of database changes. This is more preferred way than individual callback per object or per class since user may want to see all changes at single point. Each callback receives own list of changes in accordance with it's subscription criteria.</p>
<p>The changes are reported as a collection of changes per DAL class. A change per class contains 4 parameters: the class name and the identities of created, modified and removed objects.</p>
<p>To make a subscription it is necessary to make three steps: </p><ul>
<li>implement callback, </li>
<li>define subscription criteria, </li>
<li>invoke subscribe method with above entities on the configuration object.</li>
</ul>
<h2><a class="anchor" id="NM_UserCallback"></a>
7.1. User Callback</h2>
<p>To start with any subscription on database changes the user must to implement at least one ::Configuration::notify callback function in C++ or conffwk.Callback interface on Java. Below there are details for C++ and Java subscriptions.</p>
<h3><a class="anchor" id="NM_CppCallbackFunction"></a>
C++ callback function</h3>
<p>The user has to implement ::Configuration::notify callback. It has the following parameters: </p><ul>
<li><code> const std::vector&lt;::ConfigurationChange *&gt; &amp; changes </code> - description of changes </li>
<li><code> void * parameter </code> - user parameter</li>
</ul>
<p>The ::ConfigurationChange class is declared in the conffwk/Change.h file and has 4 methods to get name of the class and vectors of created, modified and removed object identities. An example of callback functions is shown below: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> callback(<span class="keyword">const</span> std::vector&lt; ConfigurationChange *&gt; &amp; changes, <span class="keywordtype">void</span> *)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The CALLBACK reports all changes:\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// iterate changes sorted by classes</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; j : changes) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print class name</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;- there are changes in class \&quot;&quot;</span> &lt;&lt; j-&gt;get_class_name() &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print modified objects</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; i : j-&gt;get_modified_objs()) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  * object \&quot;&quot;</span>  &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\&quot; was modified\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print removed objects</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; i : j-&gt;get_removed_objs()) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  * object \&quot;&quot;</span>  &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\&quot; was removed\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print created objects</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; i : j-&gt;get_created_objs()) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  * object \&quot;&quot;</span>  &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\&quot; was created\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="NM_JavaCallbackFunction"></a>
Java callback interface</h3>
<p>The user has to create a class implementing the conffwk.Callback interface. It requires to implement method void process_changes(conffwk.Change[] changes, java.lang.Object parameter). Example below illustrates how to implement notification callback: </p><div class="fragment"><div class="line"><span class="keyword">class </span>TestCallback <span class="keyword">implements</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.Callback {</div>
<div class="line">  <span class="keyword">private</span> <a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span> TestCallback(<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a> d) { db = d; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span> <span class="keywordtype">void</span> process_changes(<a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.Change[] changes, java.lang.Object parameter) {</div>
<div class="line">    </div>
<div class="line">      <span class="comment">// the parameter can be any; as an example, the callback ID is passed as string</span></div>
<div class="line">    String cb_id = (String)parameter;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// print out changes description</span></div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;[TestCallback &quot;</span> + cb_id + <span class="stringliteral">&quot;] got changes:&quot;</span>);</div>
<div class="line">    <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.Change.print(changes, <span class="stringliteral">&quot;  &quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// iterate changes by classes</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; changes.length; i++) {</div>
<div class="line">      conffwk.Change change = changes[i];</div>
<div class="line">      System.out.println(<span class="stringliteral">&quot;* there are changes in the \&#39;&quot;</span> + change.get_class_name() + <span class="stringliteral">&quot;\&#39; class&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// just as example, look for changed objects of the Application class</span></div>
<div class="line">      <span class="keywordflow">if</span>((change.get_class_name().equals(<span class="stringliteral">&quot;Application&quot;</span>) == <span class="keyword">true</span>) &amp;&amp; (change.get_changed_objects() != <span class="keyword">null</span>)) {</div>
<div class="line">        System.out.println(<span class="stringliteral">&quot;* &quot;</span> + change.get_changed_objects().length + <span class="stringliteral">&quot; updated objects of the Application class&quot;</span>);</div>
<div class="line"> </div>
<div class="line">          <span class="comment">// iterate by all changed objects and print them out</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; change.get_changed_objects().length; ++j) {</div>
<div class="line">      dal.Application a = dal.Application_Helper.get(db, change.get_changed_objects()[j]);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// an example of correct down cast</span></div>
<div class="line">      <span class="keywordflow">if</span>(a.class_name().equals(<span class="stringliteral">&quot;RunControlApplication&quot;</span>)) {</div>
<div class="line">        dal.RunControlApplication_Helper.get(db, a.config_object()).print(<span class="stringliteral">&quot;  &quot;</span>); <span class="comment">// print as RC application</span></div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span> {</div>
<div class="line">        a.print(<span class="stringliteral">&quot;  &quot;</span>); <span class="comment">// print as an application</span></div>
<div class="line">      }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="NM_SubscriptionCriteria"></a>
7.2. Subscription criteria</h2>
<p>The subscription criteria is an object of ::ConfigurationSubscriptionCriteria class in C++ or conffwk.Subscription class in Java. It is used to define lists of classes and objects, which changes will be monitored and reposted to user. If user provides no any class or object, it means subscription on any change and a database modification is reported.</p>
<h3><a class="anchor" id="NM_SubscriptionAnyClassChanges"></a>
Subscription on any changes in class</h3>
<p>The notification callback is invoked for any changes of class objects including creation of new objects, removing or modification of existing objects.</p>
<p>In C++ to subscribe on any changes in some class the user should to use ::ConfigurationSubscriptionCriteria::add(const std::string&amp;) method. For a class generated by genconffwk the s_class_name attribute can be used, e.g. to subscribe on changes in class dal::Application: </p><div class="fragment"><div class="line">::ConfigurationSubscriptionCriteria c;</div>
<div class="line">c.add(dal::Application::s_class_name);</div>
</div><!-- fragment --><p>In Java method conffwk.Subscription.add(String class_name) should be used, e.g. to subscribe on changes in class Application it is necessary to write the following code: </p><div class="fragment"><div class="line">conffwk.Subscription s = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.Subscription(<span class="keyword">new</span> TestCallback(db), <span class="keyword">null</span>);</div>
<div class="line">s.add(<span class="stringliteral">&quot;Application&quot;</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="NM_SubscriptionObjectChanges"></a>
Subscription on object changes</h3>
<p>When subscription on object changes has done, the notification callback is invoked for any changes of the objects or it's removing.</p>
<p>In C++ to subscribe on object changes notification the user should to use ::ConfigurationSubscriptionCriteria::add(const ::DalObject&amp;), e.g. to subscribe on changes of an object of the Application class: </p><div class="fragment"><div class="line">::ConfigurationSubscriptionCriteria c;</div>
<div class="line"><span class="keyword">const</span> dal::Application * app_obj;</div>
<div class="line">c-&gt;add(*app_obj);</div>
</div><!-- fragment --><p>In Java conffwk.add(DalObject obj) method to be used, e.g.: </p><div class="fragment"><div class="line">dal.Application app = ...;      <span class="comment">// some code to get application object</span></div>
<div class="line">conffwk.Subscription s = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.Subscription(<span class="keyword">new</span> TestCallback(db), <span class="keyword">null</span>);</div>
<div class="line">s.add(app);</div>
</div><!-- fragment --><h2><a class="anchor" id="NM_Subscription"></a>
7.3. Subscription</h2>
<p>To make the actual subscription it is necessary to have a notification callback been implemented and a subscription criteria object. The the method subscribe() to be invoked on the configuration object. For C++ an example is shown below: </p><div class="fragment"><div class="line">  <span class="comment">// user-defined callback</span></div>
<div class="line"><span class="keywordtype">void</span> cb(<span class="keyword">const</span> std::vector&lt;ConfigurationChange *&gt; &amp; changes, <span class="keywordtype">void</span> * p) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// configuration object</span></div>
<div class="line">  ::Configuration db(...);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// subscription criteria object</span></div>
<div class="line">  ::ConfigurationSubscriptionCriteria c;</div>
<div class="line">  c.add(dal::Application::s_class_name);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// subscription; if database is changed, the cb can be invoked after this line</span></div>
<div class="line">  ::CallbackId <span class="keywordtype">id</span> = db.subscribe(c, cb);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(daq::conffwk::Exception &amp; ex) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; ex &lt;&lt; std::endl; <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For Java above example looks like: </p><div class="fragment"><div class="line">  <span class="comment">// user-defined callback</span></div>
<div class="line"><span class="keyword">class </span>MyCallback <span class="keyword">implements</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.Callback { ... }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// configuration object</span></div>
<div class="line"><a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">conffwk.Configuration</a> db = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.<a class="code hl_namespace" href="namespaceconffwk_1_1Configuration.html">Configuration</a>(...);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// subscription criteria object</span></div>
<div class="line">conffwk.Subscription c = <span class="keyword">new</span> <a class="code hl_namespace" href="namespaceconffwk.html">conffwk</a>.Subscription(<span class="keyword">new</span> MyCallback(db), <span class="keyword">null</span>);</div>
<div class="line">c.add(<span class="stringliteral">&quot;Application&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// subscription; MyCallback::process_changes() can be invoked after this line</span></div>
<div class="line">db.subscribe(c);</div>
</div><!-- fragment --><p>The method unsubscribe() can be used to remove subscription set above. In case of C++ it's parameter is a return value of the subscribe() method (i.e. ::CallbackId value). For Java it's parameter is the subscription object used as parameter of subscribe() method.</p>
<h1><a class="anchor" id="Algorithms"></a>
8. Algorithms</h1>
<p>By default, the generated classes have one-to-one mapping to database schema and DAL objects directly correspond to the database objects. If user wants to add more algorithms on top of the generated DAL without modification of DAL code by hand, he has possibility to define algorithms on top of the OKS class methods.</p>
<p>When a class method is created, user can add it's implementation for different programming languages. To be taken into account by genconffwk, user has to provide C++ and/or Java implementation. Then he has two possibilities: </p><ul>
<li>declare method prototype, write method implementation in the separate file and add such file when build DAL; </li>
<li>declare method prototype and write it's implementation in OKS.</li>
</ul>
<p>The first way is more flexible, but requires more steps when build library. The second way does not require any additional steps when build library, but will require schema modifications to any method's implementation modification.</p>
<h1><a class="anchor" id="AdvancedCodeGeneration"></a>
9. Advanced Code Generation</h1>
<p>The OKS methods allow to insert user specific code into generated C++ and Java files and classes. In this case one has to put into method's implementation the code inside special keywords described below: </p><ul>
<li><code>BEGIN_HEADER_PROLOGUE</code> and <code>END_HEADER_PROLOGUE</code> (C++ only) Put code into C++ header file before declaration of class containing given method. </li>
<li><code>BEGIN_HEADER_EPILOGUE</code> and <code>END_HEADER_EPILOGUE</code> (C++ only) Put code into C++ header file after declaration of class containing given method. </li>
<li><code>BEGIN_PUBLIC_SECTION</code> and <code>END_PUBLIC_SECTION</code> Put code into public section of C++ or Java class containing given method. </li>
<li><code>BEGIN_PRIVATE_SECTION</code> and <code>END_PRIVATE_SECTION</code> Put code into private section of C++ or Java class containing given method. </li>
<li><code>BEGIN_MEMBER_INITIALIZER_LIST</code> and <code>END_MEMBER_INITIALIZER_LIST</code> Put code into initializer list of C++ or Java class containing given method.</li>
</ul>
<p>The online DAL defines several algorithms (e.g. to find partition, get all applications, to calculate application environment, etc.) and uses first way to implement algorithms. More information can be found in the <a href="https://twiki.cern.ch/twiki/bin/view/Atlas/DaqHltDal">dal package</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 24 2024 for DUNE-DAQ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
