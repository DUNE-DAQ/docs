<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DUNE-DAQ: daq-cmake</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DUNE-DAQ
   </div>
   <div id="projectbrief">DUNE Trigger and Data Acquisition software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">daq-cmake</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md422"></a> This package provides CMake support for DUNE-DAQ packages.</p>
<p>The documentation for this package is divided into four parts: 1) Instructions for <code>create_dunedaq_package</code>, a script which will generate a good deal of CMake/C++ code which is standard across all DUNE DAQ packages 2) A description of the standard structure and CMake build code in a DUNE DAQ package 3) A complete reference manual for the DUNE-DAQ-specific CMake functions developers can call in order to specify their package's build 4) A description of how we use schema in order to consistently define data structures</p>
<p>Note that this documentation assumes you have some familiarity with the <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/daq-buildtools">daq-buildtools package</a> and know how to set up a development area and run commands to build code in it.</p>
<h1><a class="anchor" id="autotoc_md423"></a>
The &lt;tt&gt;create_dunedaq_package&lt;/tt&gt; script</h1>
<p>A DUNE DAQ software package is composed of various types of software components - standalone applications, libraries, <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/appfwk/">DAQModules</a>, etc. Across the packages there are common ways these are implemented, whether as a result of our <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/styleguide/">official coding guidelines</a> or simply through tradition. <code>create_dunedaq_package</code> takes advantage of these patterns and saves you work by generating much of the boilerplate code which makes up a DUNE DAQ package.</p>
<p>Before using <code>create_dunedaq_package</code>, you'll want to have some idea of what software components will make up your package, and what their names should be. While the only argument actually required by <code>create_dunedaq_package</code> is the name of your new package, it won't do much unless you provide it with options and arguments. You can see what these are by running <code>create_dunedaq_package -h</code>, reprinted here for your convenience.</p>
<p>Arguments and options:</p>
<p><code>--main-library</code>: package will contain a main, package-wide library which other packages can link in</p>
<p><code>--python-bindings</code>: whether there will be Python bindings to the main library. Requires the <code>--main-library</code> option as well.</p>
<p><code>--daq-module</code>: for each "`--daq-module &lt;module name&gt;`" provided at the command line, the framework for a DAQModule will be auto-generated</p>
<p><code>--user-app</code>: same as <code>--daq-module</code>, but for user applications</p>
<p><code>--test-app</code>: same as <code>--daq-module</code>, but for integration test applications</p>
<p>Note that some of these concepts, e.g. a user-oriented app vs. an app designed for integration tests of the package itself, are covered below in the <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2daq-cmake_2docs_2README.html#package_overview">Overview of a DUNE DAQ package</a> section.</p>
<p>In the directory <code>create_dunedaq_package</code> is run out of, <code>create_dunedaq_package</code> will create a subdirectory named after your package if such a subdirectory doesn't exist. If a subdirectory with that name already <em>does</em> exist, it should be empty with the possible exceptions of a <code>README.md</code> documentation file and/or a <code>.git/</code> version control directory. These exceptions allow you to run the script using as an argument the name of a new repo which you've cloned into your area. An example of using <code>create_dunedaq_package</code> would be the following (note you can horizontal-scroll the command below): </p><div class="fragment"><div class="line">cd ./sourcecode  # If we were in the base of a development area</div>
<div class="line">create_dunedaq_package --daq-module AFirstModule --user-app an_app_for_users --user-app another_app_for_users --python-bindings --main-library thenewpackage</div>
</div><!-- fragment --><p> (Of course in real life please use better names for your package and its components than those in the example). If you were to <code>ls thenewpackage</code>, you would see that the script had set up several new directories for you, as well as a <code>CMakeLists.txt</code> file: </p><div class="fragment"><div class="line">apps</div>
<div class="line">cmake</div>
<div class="line">CMakeLists.txt</div>
<div class="line">docs</div>
<div class="line">include</div>
<div class="line">plugins</div>
<div class="line">pybindsrc</div>
<div class="line">python</div>
<div class="line">schema</div>
<div class="line">src</div>
<div class="line">unittest</div>
</div><!-- fragment --><p> where most of the directories contain boilerplate code for the software components you requested. While you'd be able to build this boilerplate package if it were in the <code>sourcecode/</code> directory of a standard DUNE DAQ development environment, the new package's components do almost nothing. Nonetheless this boilerplate code will need to be replaced, filled in and extended by the package's developers. Also if you look at <code>CMakeLists.txt</code>, you'll see that many of the function calls you'd need will have been added, though generally missing the arguments you'd need to provide them so they would know what libraries to link against, e.g.: </p><div class="fragment"><div class="line">daq_add_application(an_app_for_users an_app_for_users.cxx LINK_LIBRARIES ) # Any libraries to link in not yet determined</div>
</div><!-- fragment --><p> Obviously comments such as <code># Any libraries to link in not yet determined</code> should be deleted when it becomes appropriate.</p>
<p>Note also that a unit test is automatically generated for you <em>which is designed to fail</em>. Developers are strongly encouraged to replace it with appropriate unit tests for their package, unless it's one of those rare packages which don't need unit tests, in which case the unit test functionality should be entirely stripped from the package.</p>
<p>Now that you know how to generate the boilerplate for a DUNE DAQ package, please read on for a more in-depth understanding of what a typical DUNE DAQ package looks like.</p>
<p><a class="anchor" id="package_overview"></a> </p>
<h1><a class="anchor" id="autotoc_md424"></a>
Overview of a DUNE DAQ package</h1>
<h2><a class="anchor" id="autotoc_md425"></a>
Setting up a development area</h2>
<p>To create a new package, you'll want to install a DUNE-DAQ development environment and then create a new CMake project for the package as described in <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/daq-buildtools/">in the daq-buildtools documentation</a>.</p>
<h2><a class="anchor" id="autotoc_md426"></a>
A package's subdirectory structure</h2>
<p>To learn a bit more about how to structure your package so that it can be incorporated into the DUNE DAQ software suite, we'll play with a contrived package called "toylibrary". It's actually contained within a subdirectory of the daq-cmake repo; however, in order to be able to build toylibrary we'll want to copy it into the <code>./sourcecode</code> directory so the build system can work with it. Assuming you're already in the base directory of your development environment, do the following: </p><div class="fragment"><div class="line">git clone https://github.com/DUNE-DAQ/daq-cmake</div>
<div class="line">cd daq-cmake</div>
<div class="line">git checkout v2.2.0   # v2.2.0 corresponds to the dunedaq-v3.2.0 release</div>
<div class="line">cd ..</div>
<div class="line">mv daq-cmake/toylibrary sourcecode</div>
<div class="line">rm -rf daq-cmake</div>
</div><!-- fragment --><p> You can now build toylibrary like you would a standard DUNE DAQ package. Please note that if you do so, since toylibrary isn't an official DUNE DAQ package and isn't a git repository, you'll get a couple of warnings; unlike most warnings, you can disregard these. Specifically, these warnings are <code>Package "toylibrary" not provided to the daq_add_subpackages</code> and <code>warning: Not a git repository.</code> (and surrounding text).</p>
<p>In terms of its actual functionality, toylibrary is pretty useless (it contains a class which can wrap an integer, and another class which can print that wrapped integer). However, its functionality is beside the point; toylibrary contains many features which DUNE DAQ packages have in common, in particular DUNE DAQ packages which provide a library other developers want to link against. For starters, take a look at the subdirectories, <code>ls sourcecode/toylibrary</code>:</p>
<ul>
<li><em>src</em>: contains the source files meant to be built into the package's shared object library/libraries</li>
<li><em>include</em>: contains the headers users of your package should #include</li>
<li><em>unittest</em>: contains the <a href="https://en.wikipedia.org/wiki/Unit_testing">unit tests</a> you write to ensure that your individual classes, functions, etc. behave as expected</li>
<li><em>test</em>: contains any applications or plugins you've written for the purpose of <a href="https://en.wikipedia.org/wiki/Integration_testing">integration testing</a> - ensuring that your software components interact as expected</li>
<li><em>pybindsrc</em> contains source files which expose C++ code to python via the <code>pybind11</code> library. In <code>toylibrary</code>, we have only one such source file, <code>toy_wrapper.cpp</code>. The file provides a Python interface to the <code>IntPrinter</code> and <code>ValueWrapper&lt;int&gt;</code> classes from main <code>toylibrary</code> library. <code>toy_wrapper.cpp</code> also implements several "toy" functions, <code>WindUp</code>, <code>WindDown</code>, and <code>PlayInts</code>, which are used to demonstrate how C++ code can also be exposed via Python sub-modules.</li>
<li><em>scripts</em> This directory is inteneded to hold executable scripts. In this case it contains the script, <code>toyscript.py</code>. The <code>python</code> script demonstrates how the C++ code exposed in <code>toy_wrapper.cpp</code> can be used from within <code>python</code>.</li>
</ul>
<p>If your package contains applications intended not for testing but for the end user, you'd put the code for it in a subdirectory called <code>apps/</code>. toylibrary doesn't have this type of application, but, e.g., the appfwk package does. Similarly, plugins not intended for testing but for the end user would go in <code>plugins/</code>.</p>
<h2><a class="anchor" id="autotoc_md427"></a>
Coding rules</h2>
<p>Along with having a standard directory structure, the C++ code itself in toylibrary conforms to the <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/styleguide/">DUNE C++ Style Guide</a>. Here, "style" doesn't mean whitespace and formatting, but rather, a set of Modern C++ best practices designed to make your code more robust against bugs, easier to extend, easier to reuse, etc. The DUNE C++ Style Guide is derived from the Google C++ Style Guide, but is greatly simplified and has been modified to be more appropriate to the DUNE DAQ project than Google's projects. Code which is merged into a package's git develop branch should be in conformance with the guide; while it's encouraged for code on a package's unmerged feature branches to also be in conformance, this is less important.</p>
<h2><a class="anchor" id="autotoc_md428"></a>
Your project's CMakeLists.txt file</h2>
<p>Every DUNE DAQ package should have one and only one <code>CMakeLists.txt</code> file, in the base directory of the package's repo (not to be confused with the base directory of the overall development area). To learn a bit about what that <code>CMakeLists.txt</code> file should look like, let's take a look at <code>sourcecode/toylibrary/CMakeLists.txt</code>. Because CMake is widely used and extensively documented online, this documentation will primarily focus on DUNE-specific CMake functions. The full documentation of the DUNE-specific CMake functions for users can be found <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2daq-cmake_2docs_2README.html#cmake_function_descriptions">below</a>. Depending on your learning style, however, you may find it easier to start learning about some of what these functions are capable of by reading on without skipping.</p>
<p>At the top of <code>CMakeLists.txt</code>: before doing anything else, we want to define the minimum version of CMake used (currently 3.12, which supports <a href="https://cliutils.gitlab.io/modern-cmake/">modern CMake style</a>) as well as the name and version of the project. Concerning the version: it may not literally be the case that the code you're working with is exactly the same as the version-in-question's release code, because you may be on a feature branch, or there may have been commits to the develop branch since the last release. </p><div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.12)</div>
<div class="line">project(toylibrary VERSION 1.1.0)</div>
</div><!-- fragment --><p> Next, we want to make CMake functions written specifically for DUNE DAQ development available. Near the top of the file, you'll see the following: </p><div class="fragment"><div class="line">find_package(daq-cmake REQUIRED)</div>
</div><!-- fragment --><p> This is how we ensure that the <code>CMakeLists.txt</code> file has access to the standard DUNE DAQ CMake functions previously mentioned. When <code>find_package</code> is called here it imports daq-cmake's <code>DAQ</code> CMake module. Note that by convention all functions/macros within the module begin with <code>daq_</code>, so as to distinguish them from functions/macros from CMake modules written outside of DUNE DAQ.</p>
<p>The next step is to call a macro from the <code>DAQ</code> module which sets up a standard DUNE CMake environment for your <code>CMakeLists.txt</code> file: </p><div class="fragment"><div class="line">daq_setup_environment()</div>
</div><!-- fragment --><p> Among other things daq_setup_environment() will do the following:</p><ul>
<li>Enforce the use of standard, extension-free C++17</li>
<li>Ensure all code within the project can find the project's public headers</li>
<li>Allow our linter scripts to work with the code</li>
<li>Have gcc use standard warnings</li>
<li>Support the use of CTest for the unit tests</li>
</ul>
<p>Next you'll see calls to CMake's <a href="https://cmake.org/cmake/help/v3.17/command/find_package.html">find_package</a> function, which makes toylibrary's dependencies available. Comments in the file explain why the dependencies are selected. Please note that when developing your own package, if it's part of the nightly build and you add a new dependency, besides adding the needed <code>find_package</code> call you should also alert Software Coordination so they can add the dependency to the Spack build of the package. See below in the section called "Installing your project as a local package" for more about dependencies. <br  />
</p>
<p>Then, you'll see a call to a function called <code>daq_add_library</code>. </p><div class="fragment"><div class="line">daq_add_library(IntPrinter.cpp LINK_LIBRARIES logging::logging)</div>
</div><!-- fragment --><p> What <code>daq_add_library</code> does here is create the main project library. It looks in the project's <code>./src</code> subdirectory for a file called <code>IntPrinter.cpp</code>, which it then compiles and links against the DUNE DAQ logging library. The result is output in the installation area (<code>$DBT_INSTALL_DIR</code>) as a shared object library named after the project itself, <code>toylibrary/lib64/libtoylibrary.so</code>.</p>
<p>The next function you see called in the CMakeLists.txt file is <code>daq_add_python_bindings</code>: </p><div class="fragment"><div class="line">daq_add_python_bindings( toy_wrapper.cpp LINK_LIBRARIES ${PROJECT_NAME} )</div>
</div><!-- fragment --><p> which is a function designed to allow the binding of C++ code to python. To do so, it relies on the header only library, <code>pybind11</code>. The function expects to find the source files exposing the C++ code, in the package directory, <code>pybindsrc</code>. In this <code>toylibrary</code> case, we have specified that the bindings are located in the file <code>toy_wrapper.cpp</code>. The resulting compiled file will be called, <code>_daq_${PROJECT_NAME}_py.so</code>, and will be placed in the output installation subdirectory, <code>${PROJECT_NAME}/lib64/python/${PROJECT_NAME}</code>. Similarly to <code>daq_add_library</code>, <code>_daq_${PROJECT_NAME}_py.so</code> will be linked against the libraries specified after <code>LINK_LIBRARIES</code>. For how to import the exposed C++ in, see detailed description section. After the call of <code>daq_add_python_bindings</code>, you will see the call to the function <code>daq_add_application</code>. </p><div class="fragment"><div class="line">daq_add_application( toylibrary_test_program toylibrary_test_program.cxx TEST LINK_LIBRARIES ${Boost_PROGRAM_OPTIONS_LIBRARY} ${PROJECT_NAME} )</div>
</div><!-- fragment --><p> which searches in the projects' <code>test/apps/</code> subdirectory for a file called <code>toylibrary_test_program.cxx</code>, builds it, and links against the project's main library which we created via the previous <code>daq_add_library</code> command as well as a Boost library used to parse program input. The output application is named after the first argument to the function, <code>toylibrary_test_program</code>; it can be found in <code>$DBT_INSTALL_DIR/toylibrary/test/bin/toylibrary_test_program</code>. Note that if the "TEST" argument hadn't been supplied, the build system would have looked in a subdirectory of the project called <code>apps/</code> rather than <code>test/apps/</code> for the source file.</p>
<p>Another function currently provided by the DAQ CMake module is <code>daq_add_unit_test</code>. Examples of this function's use can be found at the bottom of the <code>sourcecode/toylibrary/CMakeLists.txt</code> file, e.g.: </p><div class="fragment"><div class="line">daq_add_unit_test(ValueWrapper_test)</div>
</div><!-- fragment --><p> If you pass this function a name, e.g., <code>MyComponent_test</code>, it will create a unit test executable off of a source file called <code>sourcecode/&lt;your packagename&gt;/unittest/MyComponent_test.cxx</code>, and handle linking in the Boost unit test dependencies. You can also optionally have it link in other libraries by providing them after the <code>LINK_LIBRARIES</code> argument as in other functions; in the above example, this isn't needed because ValueWrapper is a template class which is instantiated within the unit test code itself.</p>
<p>At the bottom of CMakeLists.txt, you'll see the following function: </p><div class="fragment"><div class="line">daq_install()</div>
</div><!-- fragment --><p> When you call it it will install the targets (executables, shared object libraries) you wish to make available to others who want to use your package in a directory called <code>$DBT_INSTALL_DIR/&lt;pkgname&gt;</code> (by default that would be <code>./install/toylibrary</code>). You'll also need to add a special file to your project for this function to work; this is discussed more fully in the "Installing your project as a local package" section later in this document.</p>
<h2><a class="anchor" id="autotoc_md429"></a>
Installing your project as a local package</h2>
<p>Use the procedure described below in order to have your package installed. Once your package is installed, it means other packages can access the libraries, public headers, etc., provided by your package via CMake's <code>find_package</code> command, i.e.: </p><div class="fragment"><div class="line"># If other users call this, they can use your code</div>
<div class="line">find_package(mypackage)</div>
</div><!-- fragment --><p>For starters, you'll want to call the DAQ module's <code>daq_install()</code> function at the bottom of your CMakeLists.txt file, as described earlier in this document.</p>
<p>A major thing you should be aware of is that when you call CMake's <code>find_package</code> function, it will look for a file with the name <code>mypackageConfig.cmake</code> in a predetermined set of directories, including the one you defined (or allowed to default to <code>./install</code>) when you initially set up your development area as described elsewhere in the documentation. What a standard <code>mypackageConfig.cmake</code> file should look like with modern CMake is documented in many places on the web, but in order to make life as easy as possible there's a templatized version of this file in the daq-cmake package. Assuming you've got a <code>./sourcecode/mypackage</code> repo in your development area, you can do the following: </p><div class="fragment"><div class="line">cd ./sourcecode/mypackage</div>
<div class="line">mkdir cmake</div>
<div class="line">cd cmake</div>
<div class="line">curl -O https://raw.githubusercontent.com/DUNE-DAQ/daq-cmake/dunedaq-v2.6.0/configs/Config.cmake.in</div>
<div class="line">mv Config.cmake.in mypackageConfig.cmake.in</div>
</div><!-- fragment --><p> and then let's look at the opening lines of <code>mypackageConfig.cmake.in</code>: </p><div class="fragment"><div class="line">@PACKAGE_INIT@</div>
<div class="line"> </div>
<div class="line">include(CMakeFindDependencyMacro)</div>
<div class="line"> </div>
<div class="line"># Insert find_dependency() calls for your package&#39;s dependencies in</div>
<div class="line"># the place of this comment. Make sure they match up with the</div>
<div class="line"># find_package calls in your package&#39;s CMakeLists.txt file</div>
</div><!-- fragment --><p> The only part of this file you need to worry about is the "Insert find_dependency()..." comment. In place of this comment, you'll want to call CMake's <code>find_dependency</code> function (details <a href="https://cmake.org/cmake/help/latest/module/CMakeFindDependencyMacro.html">here</a>) for each package that mypackage depends on; this ensures that developers who call <code>find_package(mypackage)</code> don't need to have explicit <code>find_package</code> calls on these dependencies. Please note that if you want to <em>drop</em> a dependency from your package, not only should you remove the relevant <code>find_package</code> call from <code>CMakeLists.txt</code>, you should also remove the corresponding <code>find_dependency</code> call in your <code>&lt;package&gt;Config.cmake.in</code> file.</p>
<p>You can see a simple example of this kind of file with <code>toylibrary/cmake/toylibraryConfig.cmake.in</code>.</p>
<p>Once you've edited this file as described, from the base of your development area you can then run </p><div class="fragment"><div class="line">dbt-build</div>
</div><!-- fragment --><p>without receiving an error message informing you that installation isn't an option.</p>
<p><a class="anchor" id="cmake_function_descriptions"></a> </p>
<h1><a class="anchor" id="autotoc_md430"></a>
Description of the CMake functions provided by &lt;tt&gt;daq-cmake&lt;/tt&gt;</h1>
<h2><a class="anchor" id="autotoc_md431"></a>
daq_setup_environment:</h2>
<p>Usage:</p>
<div class="fragment"><div class="line">daq_setup_environment()</div>
</div><!-- fragment --><p>This macro should be called immediately after this DAQ module is included in your DUNE DAQ project's CMakeLists.txt file; it ensures that DUNE DAQ projects all have a common build environment. It takes no arguments.</p>
<p><a class="anchor" id="daq_codegen_documentation"></a> </p>
<h2><a class="anchor" id="autotoc_md432"></a>
daq_codegen:</h2>
<p>Usage: </p><div class="fragment"><div class="line">daq_codegen( &lt;schema filename1&gt; ... [TEST] [DEP_PKGS &lt;package 1&gt; ...] [MODEL &lt;model filename&gt;]</div>
<div class="line">             [TEMPLATES &lt;template filename1&gt; ...] )</div>
</div><!-- fragment --><p><code>daq_codegen</code> uses <code>moo</code> to generate C++ headers from schema files from <code>schema/&lt;package&gt;</code> applying them to one or more templates.</p>
<p>Arguments:</p>
<ul>
<li><p class="startli"><code>&lt;schema filename1&gt; ...</code>:</p>
<p class="startli">The list of schema files to process from <code>&lt;package&gt;/schema/&lt;package&gt;</code>. Each schema file will applied to each template (specified by the TEMPLATES argument). Each schema/template pair will generate a code file named <code>build/&lt;package&gt;/codegen/include/&lt;package&gt;/&lt;schema minus *.jsonnet extension&gt;/&lt;template minus *.j2 extension&gt;</code> e.g. <code>my_schema.jsonnet</code> (from <code>my_pkg</code>) + <code>your_pkg/YourStruct.hpp.j2</code> will result in <code>build/my_pkg/codegen/include/my_pkg/my_schema/YourStruct.hpp</code></p>
</li>
<li><p class="startli"><code>TEST</code>:</p>
<p class="startli">If the code is meant for an entity in the package's test/ subdirectory, <code>TEST</code> should be passed as an argument, and the schema file's path will be assumed to be <code>test/schema/</code> rather than merely <code>schema/</code>.</p>
</li>
<li><p class="startli"><code>DEP_PKGS</code>:</p>
<p class="startli">If schema, template or model files depend on files provided by other DAQ packages, the <code>DEP_PKGS</code> argument must contain the list of packages.</p>
</li>
<li><p class="startli"><code>MODEL</code>:</p>
<p class="startli">The <code>MODEL</code> argument is optional; if no model file name is explicitly provided, <code>omodel.jsonnet</code> from the moo package itself is used.</p>
</li>
<li><p class="startli"><code>TEMPLATES</code>:</p>
<p class="startli">The list of templates to use. This is a mandatory argument. The template file format is <code>&lt;template package&gt;/&lt;template name including *.j2 extension&gt;</code>. If <code>&lt;template package&gt;</code> is omitted, the template is expected to be made available by moo.</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md433"></a>
daq_add_library:</h2>
<p>Usage: </p><div class="fragment"><div class="line">daq_add_library( &lt;file | glob expression 1&gt; ... [LINK_LIBRARIES &lt;lib1&gt; ...])</div>
</div><!-- fragment --><p><code>daq_add_library</code> is designed to produce the main library provided by a project for its dependencies to link in. It will compile a group of files defined by a set of one or more individual filenames and/or glob expressions, and link against the libraries listed after <code>LINK_LIBRARIES</code>. The set of files is assumed to be in the <code>src/</code> subdirectory of the project.</p>
<p>As an example, <code>daq_add_library(MyProj.cpp *Utils.cpp LINK_LIBRARIES logging::logging)</code> will create a library off of <code>src/MyProj.cpp</code> and any file in <code>src/</code> ending in "Utils.cpp", and links against the <a href="https://dune-daq-sw.readthedocs.io/en/latest/packages/logging/">logging library</a></p>
<p>Public headers for users of the library should go in the project's <code>include/&lt;project name&gt;</code> directory. Private headers used in the library's implementation should be put in the <code>src/</code> directory.</p>
<h2><a class="anchor" id="autotoc_md434"></a>
daq_protobuf_codegen:</h2>
<p>Usage: </p><div class="fragment"><div class="line">daq_protobuf_codegen( &lt;protobuf filename1&gt; ... [TEST] [GEN_GRPC] [DEP_PKGS &lt;package 1&gt; ...] )</div>
</div><!-- fragment --><p>Requirements for calling this function: 1) You need to call <code>find_package(opmonlib REQUIRED)</code> in your <code>CMakeLists.txt</code> file 2) You also need to call <code>daq_add_library</code>, i.e., have a main package-wide library, and link it against the opmonlib library 3) You need to call <code>find_package(gRPC REQUIRED)</code> before calling this function if you have specified <code>GEN_GRPC</code>.</p>
<p>Arguments:</p>
<ul>
<li><code>&lt;protobuf filename1&gt; ...</code>: these arguments are the list of <code>*.proto</code> files for protobuf's "protoc" program to process from <code>&lt;package&gt;/schema/&lt;package&gt;</code>. Globs also allowed.</li>
<li><code>TEST</code>: If the code is meant for an entity in the package's <code>test/</code> subdirectory, <code>TEST</code> should be passed as an argument, and the schema file's path will be assumed to be <code>test/schema/</code> rather than merely <code>schema/</code>.</li>
<li><code>GEN_GRPC</code>: if you need to cgenerate gRPC prototype for the <code>*.proto</code> files.</li>
<li><code>DEP_PKGS</code>: if a <code>*.proto</code> file given depends on <code>*.proto files</code> provided by other DAQ packages, the <code>DEP_PKGS</code> argument must contain the list of packages.</li>
</ul>
<p>Each <code>*.proto</code> file will have a C++ header/source file generated as well as a Python file. The names of the generated files are the same as per the <a href="https://protobuf.dev/">ProtoBuf API</a>: <code>*.pb.h</code> and <code>*.pb.cc</code> for the C++ header and source, respectively. gRPC files are of the form <code>*.grpc.pb.h</code> and <code>*.grpc.pb.cc</code>. The header will be installed in the public include directory. Code can link against the header in the form: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;&lt;package&gt;</span>/&lt;file_name&gt;.pb.h<span class="stringliteral">&quot;</span></div>
</div><!-- fragment --><p> The generated python file will be called <code>*_pb2.py</code> and will be installed in <code>lib64/python/&lt;package&gt;</code>. The generated python file will be called <code>*_grpc_pb2.py</code> and will be installed in <code>lib64/python/&lt;package&gt;</code>.</p>
<p>The source file will be built as part of the main package library. Its compilation will be done automatically, i.e. there is no need to add <code>*.pb.cc</code> in the <code>daq_add_library</code> directive of your package: <code>daq_protobuf_codegen</code> will suffice.</p>
<h2><a class="anchor" id="autotoc_md435"></a>
daq_add_python_bindings:</h2>
<p>Usage: </p><div class="fragment"><div class="line">daq_add_python_bindings( &lt;file | glob expression 1&gt; ... [LINK_LIBRARIES &lt;lib1&gt; ...])</div>
</div><!-- fragment --><p><code>daq_add_python_bindings</code> is designed to produce a library providing a python interface to C++ code. It will compile a group of files, which are expected to expose the desired C++ interface via <code>pybind11</code>. The set of files is defined by a set of one or more individual filenames and/or glob expressions, and link against the libraries listed after LINK_LIBRARIES. The set of files is expected to be in the <code>pybindsrc</code> subdirectory of the project.</p>
<p>As an example, <code>daq_add_python_bindings(my_wrapper.cpp LINK_LIBRARIES ${PROJECT_NAME})</code> will create a library from <code>pybindsrc/my_wrapper.cpp</code> and link against the main project library which would have been created via daq_add_library</p>
<p>Please note that library shared object will be named <code>_daq_${PROJECT_NAME}_py.so</code>, and will be placed in the <code>python/${PROJECT_NAME}</code> directory. You will need to have the corresponding init file, <code>python/${PROJECT_NAME}/__init__.py</code> to import the appropiate componenets of the module. See toylibrary for a working example.</p>
<h2><a class="anchor" id="autotoc_md436"></a>
daq_add_plugin:</h2>
<p>Usage: </p><div class="fragment"><div class="line">daq_add_plugin( &lt;plugin name&gt; &lt;plugin type&gt; [TEST] [LINK_LIBRARIES &lt;lib1&gt; ...])</div>
</div><!-- fragment --><p><code>daq_add_plugin</code> will build a plugin of type <code>&lt;plugin type&gt;</code> with the user-defined name <code>&lt;plugin name&gt;</code>. It will expect that there's a file with the name <code>&lt;plugin name&gt;.cpp</code> located either in the <code>plugins/</code> subdirectory of the project (if the <code>TEST</code> option isn't used) or in the <code>test/plugins/</code> subdirectory of the project (if it is). Like daq_add_library, daq_add_plugin can be provided a list of libraries to link against, following the <code>LINK_LIBRARIES</code> argument.</p>
<p>Your plugin will look in <code>include/</code> for your project's public headers and <code>src/</code> for its private headers. Additionally, if it's a "TEST" plugin, it will look in <code>test/src/</code>.</p>
<p>Note that if <code>cetlib</code> is a dependency of the package being built, it will be automatically linked against the plugin.</p>
<h2><a class="anchor" id="autotoc_md437"></a>
daq_add_application</h2>
<p>Usage: </p><div class="fragment"><div class="line">daq_add_application(&lt;application name&gt; &lt;file | glob expression&gt; ... [TEST] [LINK_LIBRARIES &lt;lib1&gt; ...])</div>
</div><!-- fragment --><p>This function is designed to build a standalone application in your project. Its first argument is simply the desired name of the executable, followed by a list of filenames and/or file glob expressions meant to build the executable. It expects the filenames to be either in the <code>apps/</code> subdirectory of the project, or, if the "TEST" option is chosen, the <code>test/apps/</code> subdirectory. Like daq_add_library, daq_add_application can be provided a list of libraries to link against, following the <code>LINK_LIBRARIES</code> token.</p>
<p>Your application will look in <code>include/</code> for your project's public headers and <code>src/</code> for its private headers. Additionally, if it's a "TEST" plugin, it will look in <code>test/src/</code>.</p>
<h2><a class="anchor" id="autotoc_md438"></a>
daq_add_unit_test</h2>
<p>Usage: </p><div class="fragment"><div class="line">daq_add_unit_test(&lt;unit test name&gt; [LINK_LIBRARIES &lt;lib1&gt; ...])</div>
</div><!-- fragment --><p>This function, when given the extension-free name of a unit test sourcefile in <code>unittest/</code>, will handle the needed boost functionality to build the unit test, as well as provide other support (CTest, etc.). Like daq_add_library, daq_add_unit_test can be provided a list of libraries to link against, following the <code>LINK_LIBRARIES</code> token.</p>
<h2><a class="anchor" id="autotoc_md439"></a>
daq_oks_codegen</h2>
<p>Usage: </p><div class="fragment"><div class="line">daq_oks_codegen(&lt;oks schema filename1&gt; ... [TEST] [NAMESPACE ns] [DALDIR subdir] [DEP_PKGS pkg1 pkg2 ...])</div>
</div><!-- fragment --><p><code>daq_oks_codegen</code> uses the oksdalgen package's application of the same name to generate C++ and Python code from the OKS schema file(s) provided to it.</p>
<p>Arguments:</p>
<ul>
<li><code>&lt;oks schema filename1&gt; ...</code>: the list of OKS schema files to process from <code>&lt;package&gt;/schema/&lt;package&gt;</code>.</li>
<li><code>TEST</code>: If the code is meant for an entity in the package's <code>test/</code> subdirectory, <code>TEST</code> should be passed as an argument, and the schema file's path will be assumed to be <code>test/schema/</code> rather than merely <code>schema/</code>.</li>
<li><code>NAMESPACE</code>: the namespace in which the generated C++ classes will be in. Defaults to <code>dunedaq::&lt;package&gt;</code></li>
<li><code>DALDIR</code>: subdirectory relative to the package's primary include directory where headers will appear (<code>include/&lt;package&gt;/&lt;DALDIR argument&gt;</code>); default is no subdirectory</li>
<li><code>DEP_PKGS</code>: if a schema file you've provided as an argument itself includes a schema file (or schema files) from one or more other packages, you need to supply the names of the packages as arguments to DEP_PKGS.</li>
</ul>
<p>The generated code is automatically built into the package's main library (i.e., you don't need to explicitly pass the names of the generated files to <code>daq_add_library</code>). Note that you get an error if you call <code>daq_oks_codegen</code> and don't also call <code>daq_add_library</code>.</p>
<h2><a class="anchor" id="autotoc_md440"></a>
daq_install</h2>
<p>Usage: </p><div class="fragment"><div class="line">daq_install()</div>
</div><!-- fragment --><p>This function should be called at the bottom of a project's <code>CMakeLists.txt</code> file in order to install the project's targets. It takes no arguments.</p>
<h1><a class="anchor" id="autotoc_md441"></a>
Schemas and code generation</h1>
<p><code>daq-cmake</code> supports for schema distribution and code generation with <a href="https://github.com/brettviren/moo/">moo</a>, <a href="https://protobuf.dev/programming-guides/proto3/">protobuf</a> and <a href="https://github.com/DUNE-DAQ/dal">OKS</a>.</p>
<ol type="1">
<li>Schemas (jsonnet), models (jsonnet) and templates (Jinja) in the <code>schema/&lt;package name&gt;</code> folder are automatically copied to the installation directory and into Spack products eventually.</li>
</ol>
<ol type="1">
<li>The <code>daq_codegen</code> cmake function provides a simpliefied interface to <code>moo render</code> to generate C++ files from Jinja templates. It provides a mechanism to easily import schemas, templates or models from other packages and implements a time-related dependency check. Details are <a class="el" href="md__2github_2workspace_2dev__area_2sourcecode_2daq-cmake_2docs_2README.html#daq_codegen_documentation">above</a>.</li>
</ol>
<p><a class="anchor" id="daq_cmake_schema"></a> </p>
<h2><a class="anchor" id="autotoc_md442"></a>
Schema files</h2>
<p><code>daq-cmake</code> handles schemas in a similar fashion to C++ headers. Where header files are located according to the namespace of the class they declare (e.g. <code>mypkg::MyClass</code> in <code>include/mypkg/MyClass.hpp</code>, schemas location in the package is determined by the schema path (e.g. <code>mypkg.myschema</code> in <code>schema/mypkg/myschema.jsonnet</code>). In both cases the package name is integral part of the namespace/path to ensure uniqueness of the declared entities.</p>
<p>As an example, below is shown the organization of the <code>appfwk/schema</code> folder:</p>
<div class="fragment"><div class="line"><a class="code hl_namespace" href="namespaceappfwk.html">appfwk</a>/</div>
<div class="line">├── apps</div>
<div class="line">├── cmake</div>
<div class="line">├── CMakeLists.txt</div>
<div class="line">├── docs</div>
<div class="line">├── include</div>
<div class="line">├── python</div>
<div class="line">├── schema</div>
<div class="line">│   ├── <a class="code hl_namespace" href="namespaceappfwk.html">appfwk</a></div>
<div class="line">│   │   ├── app.jsonnet</div>
<div class="line">│   │   ├── cmd.jsonnet</div>
<div class="line">│   │   └── opmon</div>
<div class="line">│   │       └── appinfo.proto</div>
<div class="line">│   └── README.md</div>
<div class="line">├── src</div>
<div class="line">├── test</div>
<div class="line">└── unittest</div>
<div class="ttc" id="anamespaceappfwk_html"><div class="ttname"><a href="namespaceappfwk.html">appfwk</a></div><div class="ttdef"><b>Definition</b> <a href="appfwk_2python_2appfwk_2utils_8py_source.html#l00001">utils.py:1</a></div></div>
</div><!-- fragment --><p><code>cmd.jsonnet</code> declares <code><a class="el" href="namespacedunedaq_1_1appfwk_1_1cmd.html">dunedaq.appfwk.cmd</a></code> schema structures with the following statement</p>
<div class="fragment"><div class="line">local s = moo.oschema.schema(&quot;dunedaq.appfwk.cmd&quot;);</div>
</div><!-- fragment --><p>The same applies to <code>app.jsonnet</code> for <code>dunedaq.appfwk.app</code>.</p>
<p>The matching between the schema file name/path and the jsonnet namespace is essential for code generation with <code>daq-cmake</code>. A mismatch between the two will result in empty generated files in most of the cases. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 24 2024 for DUNE-DAQ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
